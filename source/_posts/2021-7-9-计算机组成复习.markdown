---
layout:     post
title:      "计算机组成复习"
intro:   ""
date:       2021-7-9 21:00:01
author:     "Makinohara"
catalog: true
tags:
    - 计算机基础
    
---

# 计算机技术指标

## CPU执行时间：

$$
Te = m/F
$$
$$
Te = m*T
$$

m：CPU时钟周期数；T：时钟周期；F：频率

## CPI 每条指令平均时钟周期数：

$$
CPI = m/IC
$$

$$
CPI = \sum\limits_{i=1}^N (CPI_i*IC_i)/IC
$$

IC：指令条数(总的)

## MIPS每秒百万条指令数：

$MIPS = IC/(Te*10^6)$

$MIPS = F/(CPI*10^6)$

# 存储系统

## 半导体容量扩展：

1.线选法

用一根地址线选择一块芯片

2.全译码法

将全部地址线译码，地位直接用于片内寻址，高位用译码器译码后进行片选。（地址唯一、连续、没有地址重叠）

3.部分译码法：

将高位地址的部分地址线用于译码，部分不参与译码（所以可能会产生地址重叠，比如最高位为1和为0选择同一芯片，所以地址就重叠了）。

### 拓展方式：

1.位拓展方式

拓展每个字的位数

将芯片的地址线、片选信号和读写控制并联（视为一个芯片），然后将数据线分别连到各个芯片。

2.字拓展方式

拓展字数

将芯片的地址线、数据线和读写控制并联，然后将片选信号连到各个芯片。

3.字位拓展方式

同时拓展字数和位数

将所有芯片的读写控制线连到一起

将同一区域（位扩展）的芯片片选信号连到一起，不同区域的片选信号分开

将同一区域中不同芯片的数据线分别连接到应有的位置上

## Cache：

读：

CPU发出读请求后，先由Cache控制器判断请求的字是否在Cache中，若命中，则对Cache读，否则从主存读所需字送CPU，并把该字所在块送Cache，如果Cache已满，则调用替换算法。

写：

1、写直达：

在写数据时既写入主存又写入Cache。

2、写回法：

在写入数据时先写入Cache，直到该块被替换时才写入主存。每个块需要设置一个“修改位”来判断是否要将这个块存回主存原来位置。

### Cache主存地址映像与变换

1.全相连映像：

将主存中的块映射到Cache中的任意一块，使用相联存储器按内容寻址。

```
主存:   主存块号+块内地址
          ↓      ↓
查不到  ←相连比较   ↓
         ↓       ↓
        查到      ↓
         ↓       ↓
Cache: Cache块号+块内地址
```

2.直接映像：

将主存映射到Cache中的一个固定块位置

$i = j mod C $

$i = j mod 2^c$

i:Cache块号；j:主存块号 C:块数 c：Cache位数

```
主存：主存字块标记(t位)+Cache字块地址(c位)+块内地址(b位)
Cache：块号(c位)+块内地址(b位)
其中，在主存通过Cache字块地址找到对应到Cache中哪一块后，
再通过标记表的t位标记是否和主存字块t位标记相等判断是否命中。
```

3.组相连映像：

先把Cache分为Q组，每组R块

$k = j\ mod\ Q$

k:Cache组号；j:主存块号

块号为j的主存块影响到Cache中的块号为：

$i = k*2^r+h$

$2^r$:组内块号。r= 1, 每组2块；h:组内偏移，这个值是随机的，由于主存的一块会映射到Cache某组的任意一块。

r=0:每组1块，此时直接映像；r=c:每组$2^c$块，也就是只分一组，此时组内块号就是块号（Cache块号与主存块号），此时为全相连映像。

```
主存:主存字块标记(t+r)+组号(c-r)+块内地址(b)
         ↓         ↓            ↓ 
      相联比较↘     ↓            ↓
         ←←←←←←←←←←←            ↓             
         ↓       ↘              ↓ 
Cache:组号(c-r)+组内块号(r)+块内地址(b)

备注：r越大，组越少，r=c，全是主存字块标记，此时全相连;
r=0，组号为c，此时组号等同于块号(每组只有一块)，而主存的t位标记仍然通过标记表的t位比较是否相等，相等则命中。
```

```
在此种模式中，每组有一个相连比较表（只有一组就只有一个，即全相连），
首先先得出是哪一组的相连比较表，用主存标记t位相连比较，如相等，则得出组内块号，命中，如不相等，失效。

主要思想：分组进行组内的全相连，c=0就是只分一组，也就是正统的全相连。
```

# 指令系统

1、指令根据操作码数目分为零地址、一地址、二地址、三地址指令等。

## 指令系统设计

固定长编码：所有操作码的长度都是相等的。

Huffman编码：根据指令的出现概率编码，概率大的长，概率小的短。

编码过程：按出现概率自左向右排序，然后抽出概率最低的两个形成一个树，根节点是两者之和。然后重复，直到根节点概率为1。

指令由Huffman树确定，左边的子节点为0，右边为1，以此类推。

### 扩展编码：

a/b(m-n)扩展编码：a、b是有相同长度的编码数目，m、n是码长。

比如2/7、2-4代表的是同一种编码。

其中，比较短的编码的全1（比如：1111）一般用于作为前缀，代表切换至更长长度的编码。

算编码数：以编码为3-6-9-扩展编码为例

$S_9 = ((2^3-S_3)\cdot2^{6-3}-S_6)\cdot2^{9-6}$

其中，Sn代表码长为n的编码数目。

解释：$2^3-S_3$ 表示了在表示完码长为3的编码后，剩余的前缀数目。这些前缀可以用来拓展到6位。如果剩余的前缀越多，可以拓展出的组也就越多，然后再乘以每组可以表示的6码长编码数目（由于前3位是前缀，实际上只有$2^{6-3}$种结果），得到一共可以表示多少码长为6编码，再减去实际的，得到前缀数，以此类推，得到码长为9的编码可以表示的数目。

# 控制器

## 控制器基础

### 控制器组成

程序计数器PC：存指令的地址

指令寄存器IR：保存指令的内容

指令译码器ID：分析识别是怎样的指令

地址形成部件：根据不同的寻址方式形成操作数的有效地址。

脉冲源：作为时钟脉冲

启停线路：计算机启动信号，启动后时钟脉冲才能进入，然后启动节拍信号发生器开始工作。

节拍信号发生器：将脉冲转换为各个设备所需要的节拍信号

控制单元：将指令发出的各种控制信号按节拍分配。

中断控制逻辑：控制中断。

### 寄存器：

通用+PC+IR+AR（记录主存单元地址）+DR（数据缓冲寄存器，在CPU和主存间形成缓冲）+PSW（记录各种条件码，比如进位）

## 微程序控制

### 关于容量：

CS容量：$2^{N_{AR}} \cdot N_{IR} $，前者代表多少指令，后者代表每条指令多少位

IR位数：微程序位数，否则放不下

AR位数：下址位数

### 微指令编码方式：

直接控制法：每一位代表一个微命令

字段直接编译法：

1、微命令数=$2^n-1$，因000要代表不发出微命令。

2、每个互斥类可能有多个编码，但是互斥类之间是平行排布的，平铺在控制字段。下址字段则是固定的，存下条指令地址。

例如：

```
组1|组2|组3|......|判别码|下址|
每个组是一个互斥类，代表2^n-1个指令。
```

### 微指令执行方式：

串行方式：在一条微指令执行完毕后才会执行下一条

并行方式：在一条微指令执行时，就取下一条微指令
