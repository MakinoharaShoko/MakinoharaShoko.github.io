{"pageProps":{"post":"---\nlayout:     post\ntitle:      NestJS 认证与认证初步\nintro:   \"\"\ndate:       2022-5-27 15:30:00\nauthor:     \"Mahiru\"\ncatalog: true\ntags:\n    - 工程开发\n---\n\n## Local 认证\n\n#### 首先，准备包 Passport\n\n```shell\nyarn add @nestjs/passport passport passport-local\nyarn add @types/passport-local\n```\n\n#### 创建 Auth 模块和 User 模块\n\n**UserService需要做什么？**\n\n提供用户数据。\n\nUser模块的创建没有太多标准，只需要是一个单例，提供用户数据即可。在实际应用中应该再这里构建用户模型和持久层。\n\n其中，User模块需要提供用户数据并提供方法来返回用户数据，并且需要在模块中导出。\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n\n```\n\n**AuthService需要做什么？**\n\n**提供认证的具体实现，提供JWT等......**\n\n提供认证实现的一个例子：\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private readonly usersService: UsersService) {}\n\n  async validateUser(username: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}\n\n```\n\n**在实际的应用程序中，我们不会以纯文本形式存储密码。 取而代之的是使用带有加密单向哈希算法的 `bcrypt` 之类的库。**\n\nAuth 模块需要导入用户模块和PassportModule，用于认证。\n\nAuth 模块的Provider 是 AuthService 和 LocalStrategy（用于提供认证策略）。\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}\n```\n\n#### 实现策略\n\n在`local.strategy.ts` 中实现策略，策略的具体实现依赖于 AuthService\n\n```typescript\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private readonly authService: AuthService) {\n    super();\n  }\n\n  async validate(username: string, password: string): Promise<any> {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}\n\n```\n\n### local 认证\n\n**别忘了导入 AuthModule ！**\n\n在Controller 中引入 `@UseGuards`\n\n```typescript\nimport { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller('testguard')\nexport class TestguardController {\n  // 在这里引入需要的认证守卫！\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  async login(@Request() req) {\n    return req.user;\n  }\n}\n\n```\n\n也可以将要使用的AuthGuard 写成一个类\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class LocalAuthGuard extends AuthGuard('local') {}\n```\n\n引入方式变为 `@UseGuards(LocalAuthGuard)`\n\n## JWT 方式\n\n### JWT 生成\n\n#### 引入包\n\n```shell\nyarn add @nestjs/jwt passport-jwt\nyarn add @types/passport-jwt\n```\n\n#### 在 AuthService 中加上 JWT\n\n```typescript\nconstructor(\n    private readonly usersService: UsersService,\n    private readonly jwtService: JwtService, // 别忘了在这里实例化 JwtService\n  ) {}\n\nasync login(user: any) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n```\n\n我们使用 `@nestjs/jwt` 库，该库提供了一个 `sign()` 函数，用于从用户对象属性的子集生成 `jwt`，然后以简单对象的形式返回一个 `access_token` 属性。注意:我们选择 `sub` 的属性名来保持我们的 `userId` 值与`JWT` 标准一致。不要忘记将 `JwtService` 提供者注入到 `AuthService`中。\n\n我们使用 `register()` 配置 `JwtModule` ，并传入一个配置对象。\n\n#### 修改 AuthService\n\n```typescript\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n别忘了导出 `AuthService` 这样使用这个模块的Module 才能获取 `AuthService`\n\n#### 更新 Controller\n\n因为 Passport 定义的 **所有策略** 都是将validate() 方法执行的结果作为 user 属性存储在当前 **HTTP Request 对象** 上，所以我们可以得到 `username` 和 `userId`。\n\n```typescript\n@Controller('testguard')\nexport class TestguardController {\n  constructor(private readonly authService: AuthService) {}\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n}\n```\n\n这样，我们就能得到 `AccessToken`。\n\n`POST localhost:3000/testguard/auth/login`\n\nx-www-form-urlencoded:`username=john&passwoed=changeme`\n\n返回：\n\n```JSON\n{\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG4iLCJzdWIiOjEsImlhdCI6MTY1MzY0MDUyMiwiZXhwIjoxNjUzNjQwNTgyfQ.gvMROxXrL_ywMDNf2IbReCxgrh6_FQYh10M34A8JxwM\"}\n```\n\n### JWT 认证\n\n#### 编写 JWT 策略\n\n`auth/jwt.strategy.ts`\n\n对于 `JWT` 策略，`Passport` 首先验证 `JWT` 的签名并解码 `JSON `。然后调用我们的 `validate()` 方法，该方法将解码后的 `JSON` 作为其单个参数传递。\n\n所以，实际上我们的 `validate` 是拿到了解码后的 `JSON`，这个 `payload` 正是我们之前通过 `sign` 生成的。\n\n所以我们只需要返回其内容。\n\n```typescript\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}\n```\n\n**在 `AuthModule` 中添加新的 `JwtStrategy` 作为提供者，因为现在我们提供了 JWT 作为认证方式**\n\n```typescript\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n#### 然后，引入这个策略\n\n`jwt-auth.guard.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n\n```\n\n#### 修改 Controller\n\n```typescript\nimport { Controller, Request, Post, UseGuards, Get } from '@nestjs/common';\nimport { AuthService } from '../auth/auth.service';\nimport { LocalAuthGuard } from '../auth/local-auth.guard';\nimport { JwtAuthGuard } from '../auth/jwt-auth.guard';\n\n@Controller('testguard')\nexport class TestguardController {\n  constructor(private readonly authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('info')\n  async getInfo(@Request() req) {\n    return req.user;\n  }\n}\n\n```\n\n#### 测试\n\n在 Get 时加上 请求头\n\n```\nAuthorization: Bearer [Access Token]\n```\n\n即可访问被 `JwtAuthGuard` 保护的数据。\n\n## 总结\n\n实现认证总是需要编写以下模块：\n\n1、`UserModule` ，作为用户数据的提供者（提供账号密码等）\n\n2、`AuthModule`，用于提供认证策略，实现认证服务。\n\n### UserModule 需要编写什么？\n\n#### UserService\n\n获取用户数据的逻辑，**这个模块需要导出并由`AuthService`引入**。\n\n### AuthModule 需要编写什么？\n\n#### AuthService\n\n这个服务用于：具体实现local认证（因为密码可能散列），生成`JWT`（一般来说在生成`JWT`前已经由Local认证，并得到用户信息，这时候根据用户信息来生成`JWT`）\n\n这个服务需要导入：`UserSercice`（用于Local认证），`JwtService`（用于生成`JWT`）\n\n#### AuthModule\n\n需要导入的：`UserModule`（用于让Service可以拿到用户数据）、`PassportModule` （我们实现认证的库）、`JWTModule`（用于生成`JWT`，并配置`JWT`参数）\n\n这个模块的提供者：`AuthService`（提供认证具体实现）、`LocalStrategy`， `JwtStrategy`（具体策略）\n\n需要导出的：`AuthService`（为什么？因为我们需要这个服务来生成`JWT`，Controller 需要这个服务来获得 `JWT`并响应。\n\n#### 编写策略\n\n所有的策略都是继承 `PassportStrategy(Strategy)`，实现 `validate` 方法。\n\n`validate` 方法总是接受来自 `req` 的属性，返回的属性也会附加到 `req` 。一旦认证结束后，我们就可以从 `req`对象中拿到认证的结果。\n\n策略的核心在于在发生错误的时候抛出 `UnauthorizedException()` 来告知无法认证，在认证通过的时候往 `req`对象上附加一些属性（这些属性可以用于返回，也可以用于生成 `JWT`）。\n\n策略会调用 `AuthService` ，因为那里有认证的具体实现。\n\n#### 收尾\n\n可以导出 `jwt-auth.guard.ts`、  `local-auth.guard.ts` 简化在Controller 使用 `@UseGuards`注解时要编写的代码。\n"},"__N_SSG":true}