{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"C Programing Language\"\nintro:   \"\"\ndate:       2019-11-12 10:13:00\nauthor:     \"Makinohara\"\nfeatured_image: http://msfasr.com/img/post-bg-css.jpg\ncatalog: true\ntags:\n    - 编程语言\n---\n\n> This is a note about The C programing language .\n>\n> I'm refactoring this note into English, too. \n\n## C Basic Knowledge\n\n#### C variable , data types\n\nC语言中存在已经定义好的数种数据类型,每种数据类型都有其可表示值的范围.\n\n*接下来要背书了,学个计算机有时候就是和学高中语文一样难受.*\n\n下表列出了关于标准整数类型的存储大小和值范围的细节：\n\n| 类型           | 存储大小    | 值范围                                                       |\n| :------------- | :---------- | :----------------------------------------------------------- |\n| char           | 1 字节      | -128 到 127 或 0 到 255                                      |\n| unsigned char  | 1 字节      | 0 到 255                                                     |\n| signed char    | 1 字节      | -128 到 127                                                  |\n| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 `依环境而定` |\n| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295 `依环境而定`               |\n| short          | 2 字节      | -32,768 到 32,767                                            |\n| unsigned short | 2 字节      | 0 到 65,535                                                  |\n| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                              |\n| unsigned long  | 4 字节      | 0 到 4,294,967,295                                           |\n\n下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：\n\n| 类型        | 存储大小 | 值范围                 | 精度      |\n| :---------- | :------- | :--------------------- | :-------- |\n| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |\n| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |\n| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |\n\n\n\n#### Functions of Input and Output\n\n#### scanf\n\nscanf是格式化输入的函数,可以将用户从键盘输入的内容写到一个地址中去.scanf的使用格式是这样的:\n\nscanf(\"%d\",&a);\n\n%d代表输入的是一个整型变量,相类似的还有%f(浮点型变量),%lf(长浮点型变量),%c(字符型变量),%s(字符串).\n\n### File R/W\n\n```c\n#include<stdio.h>\nint main()\n{\n    //fopen\n    FILE *p = fopen(\"filename\",\"r\");\n    char str[100] = {0};\n    fscanf(p,\"%s\",str);\n    \n    //freopen\n    freopen(\"filename\",\"r\",stdin);\n    scanf(\"%s\",str);\n}\n```\n\n\n\n### Preprocessing command\n\nPreprocessing command normally be placed before the start of function definition. It is used to process something before compile .\n\n#### Macro definition\n\nMacro definition normally starts with # , such as:\n\n```c\n#define\n#include\n```\n\nThe rules of using macro definition:\n\n```c\n#define PI 3.1415926//不含参数的构造,语句结束不需要分号,#include亦然\n//编译器会直接将所有的PI替换为3.1415926\n#define R 3.0\n#define L 2*PI*R\n//以上的两行也是可以的,宏定义会展开.\nprintf(\"L\");//格式控制输出时不置反\n\n#define S(a,b) a*b//含参构造,遇到S(数字,数字),替换为a*b\n```\n\n宏名一般使用大写字母表示,这是一种约定俗成的规则.\n\n宏定义不会为标识符分配内存空间\n\n宏定义的终止:\n\n```c\n#undefine PI\n```\n\n#### File includes\n\n```c\n#include<file name>\n#include\"file name\"//偏向于用户自定义部分\n```\n\n#### Conditional Compile\n\n```c\n#ifdef //flag\n#define LETTER 1\n\n#if LETTER\n//code\n#else\n//code\n```\n\n### Pointer\n\nPointer is a sort of variable that storages address.\n\nHere are some basic operations of using pointer.\n\n```c\nint a=3;\nint *ptr = &a;//ptr is a variable that points to the address of a\n*ptr;//use * to access the data at the address which ptr points to.\n*(ptr++);//returns *ptr,and then ptr++\n```\n\n#### **Use pointer to access array:**\n\n```c\nint a[]={1,2,3,5,2,6,2,5}\nint *ptr = &a;//the address of an array is just same as the address of the first element of the array.\nprintf(\"%d\",*ptr++); //the ptr++ refers the pointer is going to point to the next element of the array\n```\n\nUse pointer to access multi dimension array;\n\n| Array    | Use variable | Use pointer  | Use pointer | Use pointer     |\n| -------- | ------------ | ------------ | ----------- | --------------- |\n| a[i]     | a[i]         | *(a+1)       | *(a+1)      | *(a+i)          |\n| a\\[i][j] | a\\[i][j]     | *(\\*(a+i)+j) | *(a[i]+j)   | *(\\&a\\[i][0]+j) |\n\nAn address like **a** (the array is a\\[3][3]) can't be a value of int *p;\n\nSo,how to do that?\n\nUse int (*p)[4] , a pointer of this type can have a value like a (the array is a\\[2][4]).\n\n#### Pointer Array\n\n```c\nint *p[4];//a define of a pointer array\nchar *p[4]={\"Brazil\",\"Russia\",\"India\",\"China\"};//a array of pointer,each points to a string.\n```\n\n**Sort a char *p[]**\n\n```c\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint main()\n{\n    char *p[]={\"Aa\",\"Bb\",\"Cc\",\"Dd\"};\n    for(int i=0;i<4;i++)\n    {\n        int pos =i;\n        char max = *p[i];\n        for(int j=i;j<4;j++)\n        {\n            if(*p[j]>max)\n            {\n                max=*p[j];\n                pos=j;\n            }\n        }\n        char* t= p[i];\n        p[i]=p[pos];\n        p[pos]=t;\n    }\n\n    \n    return 0;\n}\n```\n\n\n\n#### Dynamic Memory Space\n\n```c\nint *p = (int*)malloc(4);; //set a space whose size is 4.\nint *p[4] = (int*)calloc(n,sizeof(int));//set n*size array.\nrealloc(p,8);//resize.\nfree(p);//delete.\n```\n\n#### Pointer to Pointer\n\n```c\nint **p;\n**p=2;\n*p;//an address\n**p;//a value\n```\n\n#### Parameters to main\n\n```c\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint main(int argc,char* argv[])//argc refers string numbers and argv refers string that put in.\n    //argv[0]=your program name\n{\n    for(int i=1;argv[i]!=NULL;i++)\n    printf(\"%s\\n\",argv[i]);\n\n    \n    return 0;\n}\n```\n\n### Dynamic Memory space\n\nMalloc\n\n```c\nint main()\n{\n    struct Student *head;\n    head = (struct Student *)malloc(sizeof(struct Student));\n}\n```\n\nCalloc\n\n```c\nint main()\n{\n    head = (struct Student*)calloc(100,sizeof(struct Student))\n}\n```\n\nRealloc\n\n```c\nint main()\n{\n    realloc(*p,size);\n}\n```\n\nFree\n\n```c\nint main()\n{\n    free(*p);\n}\n```\n\nExample:\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n\nstruct Student \n{\n    int age=0;\n    struct Student *next=NULL;\n};\n\nint main()\n{\n    struct Student *head,*current;\n    int i=0;\n    head = (struct Student*)malloc(sizeof(struct Student));\n    current=head;\n    while(i==0)\n    {\n        printf(\"Add student? 0/yes 1/no\\n\");\n        scanf(\"%d\",&i);\n        if(i==0)\n        {\n            printf(\"input age\\n\");\n            scanf(\"%d\",&(*current).age);\n            (*current).next=(struct Student*)malloc(sizeof(struct Student));\n            current = (*current).next;\n        }else\n        {\n            (*current).age=0;\n            (*current).next=NULL;\n        }\n        \n    }\n    return 0;\n}\n```\n\n## File operation\n\n#### File pointer\n\n```c\nFILE *fp;//create a pointer point to the head of the file.\nfp = fopen(\"file.txt\",\"a+\");//open the file.\nfclose(fp);\n```\n\n#### File functions\n\n```c\n//freopen\nfreopen(\"File\",\"a+\",stdin);\nfreopen(\"File\",\"w\",stdout);\nfclose(ptr);//or the file will not be write.\n\nfgetc(fp);\nfputc(ch,fp);\n//read and write character in a file.\n\nfgets(str,n,fp);//See carefully, there's n in parameter list, n refers the string's length is n-1 .\nfputs(str,fp);\n\nfscanf(fp,\"Format\",parameter list);\nfprintf(fp,\"Format\",parameter list);\n\n//read and write in bit\nfread(buffer,size,count,fp);\nfwrite(buffer,size,count,fp);\n\n//examples:\nfread(&stu_list[i],sizeof(struct student),1,fp);\nfwrite(&stu_list[i],sizeof(struct student),1,fp);//you can see it as using disk as memory.\n\n```\n\n#### Radom R/W files\n\n```c\nrewind(fp);//move the file flag back to the head.\nfseek(fp,100L,0);//move the flag to the position 100 byte away from the head.\nfseek(fp,100L,1);//move foward 100 byte from current position\nfseek(fp,-50L,3);//move back 50 byte from the end.\n```\n\n| start position   | name     | number reference |\n| ---------------- | -------- | ---------------- |\n| head             | SEEK_SET | 0                |\n| current position | SEEK_CUR | 1                |\n| end              | SEEK_END | 2                |\n\n"},"__N_SSG":true}