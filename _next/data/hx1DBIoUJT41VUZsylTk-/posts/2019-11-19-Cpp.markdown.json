{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"C++语言学习笔记\"\nintro:   \"\"\ndate:       2019-11-19 16:00:00\nauthor:     \"Makinohara\"\nfeatured_image: http://msfasr.com//img/cpp.jpg\ncatalog: true\ntags:\n    - 编程语言\n---\n\n[TOC]\n\n\n\n> I'm refactoring this note into English version. This may spend me lots of time.\n>\n> But I believe it will be a good form for me to learn English.\n>\n> Carry on! \n\n# C++ Language Studying(Section 1)\n\n## Basic C++ Knowledge\n\n### Some tiny knowledge points\n\n1B=8bit(B refers byte and b refers bit)\n\n## C++ I/O\n\n\n\n## C++ Sentences\n\n#### Range for\n\n```c++\nfor(auto s:str1)\n{\n    cout<<S<<endl;\n}\n```\n\nBy using range for, you can process each element in an array or a sequence .\n\n## C++ 类\n\n众所周知，支持面向对象编程是C++的一个重要特性，接下来我们来看类。\n\n```c++\nclass Box\n{\n   public:\n      double length;   // 盒子的长度\n      double breadth;  // 盒子的宽度\n      double height;   // 盒子的高度\n};\n```\n\n带成员函数声明和定义：\n\n```c++\nclass Box\n{\n   public:\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度\n      // 成员函数声明\n      double get(void);\n      void set( double len, double bre, double hei );\n};\n// 成员函数定义\ndouble Box::get(void)\n{\n    return length * breadth * height;\n}\n \nvoid Box::set( double len, double bre, double hei)\n{\n    length = len;\n    breadth = bre;\n    height = hei;\n}\n```\n\n### 析构函数：\n\n```c++\nclass String{\nprivate:\n    char* p;\npublic:\n    String(int n);\n    ~String();\n};\nString::~String(){   //析构函数\n    delete[] p;\n}\nString::String(int n){\n    p = new char[n];\n}\n```\n\n\n\n### c++继承\n\n```c++\n// 基类\nclass Shape \n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n \n// 派生类\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }\n};\n\n//多继承\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…\n{\n<派生类类体>\n};\n```\n\n\n\n重载：\n\n```c++\n//运算符重载：\nBox operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n\n//函数重载：\nclass printData\n{\n   public:\n      void print(int i) {\n        cout << \"整数为: \" << i << endl;\n      }\n \n      void print(double  f) {\n        cout << \"浮点数为: \" << f << endl;\n      }\n \n      void print(char c[]) {\n        cout << \"字符串为: \" << c << endl;\n      }\n};\n```\n\n\n\n## 命名空间\n\n```c++\n// 第一个命名空间\nnamespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }\n}\n// 第二个命名空间\nnamespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }\n}\nint main ()\n{\n \n   // 调用第一个命名空间中的函数\n   first_space::func();\n   \n   // 调用第二个命名空间中的函数\n   second_space::func(); \n \n   return 0;\n}\n```\n\n## 王氏C++——应付考试内容\n\n```c++\n//自由函数与成员函数，运算符重载的不同\n\n#include<bits/stdc++.h>\nclass complex{\n    public:\n    complex(int ri = 0, int ii = 0){\n        r = ri;\n        i = ii;\n    }\n    int r;\n    int i;\n    friend complex operator+(const complex &b) ;//友元函数\n    //complex operator+(const complex &b) const;  成员函数\n};\n\ncomplex operator+(const complex &a,const complex &b) {\n    return complex(a.r+b.r,a.i+b.i);\n}\n\n/*\n成员函数\ncomplex complex::operator+(const complex &b) const{\n    return complex(r+b.r,i+b.i);\n}\n*/\n\nint main(){\n    complex c1(1,1);\n    complex c2(2,2);\n    complex c3 = c1+c2;\n    complex c4 = c2+3;//成员函数无法执行此操作，而友元函数会得出结果c4.r = c2.r+3,c4.r = c2.r;\n    return 0;\n}\n\n//有关数组一说\nfloat[2] x[100];//这是每个元素为2个float元素为元素的数组的数组。但是是错的，编译不通过。\n```\n\n### 引用：\n\n```c++\nint x = 5;\nint &rx = x;\n//rx = 7->x = 7\n```\n\n### 函数：\n\n```c++\ndatatype func_name(datatype a){\n\t\n}\n\ndatatype func_name(datatype &rr){\n    rr = 2;\n}\n\ndatatype func_name(const float &rr){\n    rr = 2;//ERROR\n}\n\n//example:\nint fun(int &i){\n    i = 36;\n    return i;\n}\n\nint main(){\n    int i = 3;\n    int f = fun(i);\n    return 0;\n}\n\n//数组名做参数\nint calcsum(int x[],int size){\n    int sum;\n    for (int i = 0; i < size; i++)\n    {\n        sum+=x[i];\n    }\n    return sum;\n}\n\nint main(){\n    int x[2]={1,2};\n    int sum = calcsum(x,2);\n    return 0;\n}\n\n\n```\n\n\n\n### 有关类的四个基本函数\n\n```c++\nclass Clock{\n    private:\n    int a;\n    int b;\n    public:\n    clock(int a, int b);//构造函数\n    clock();//默认构造函数\n    clock(int i,int j){\n        a = i;\n        b = j;\n    }\n    \n    //初始化列表：\n    clock(int s, int i):a(s), b(i){};\n    \n    //析构函数\n    ~clock;\n    \n    //拷贝构造函数\n    clock(const clock &c){\n        a = c.a;\n        b = c.b;\n    }\n    \n    //拷贝赋值函数\n    clock& operator=(const clock &c){\n        if (&c!= this){   //避免自己拷贝自己的情况\n            a = c.a;\n            b = c.b;\n        }\n        return *this;\n    }\n    \n}\n```\n\n### 常函数：\n\n\n\n```c++\nclass circle{\n    private:\n    int r;\n    public:\n    int getR(){\n        return r;\n    }\n    circle(int i){\n        r = i;\n    }\n\n    float getArea() /*(const)*/{\n        return 3.1415926 *r*r;\n    }\n    float getAreaC() const){\n        return 3.1415926 *r*r;\n    }\n};\n\n\n\nint main(){\n    const circle c1(1);\n    float area = c1.getArea();//错误，不是常函数无法访问const修饰的对象\n    float area = c1.getAreaC();//正确\n    return 0;\n}\n```\n\n\n\n### 继承：\n\n```c++\nclass circle2:/*(private or protected or public)*/circle{\n    ......\n}\n```\n\n### 虚函数：\n\n```c++\n#include<iostream>\n\nclass Base1{\n\tpublic:\n    virtual void display() const;\n};\n\nvoid Base1::display() const{\n    std::cout<<1<<std::endl;\n}\n\nclass Base2:public Base1{\n    public:\n    void display() const ;\n};\nvoid Base2::display() const{\n    std::cout<<2<<std::endl;\n}\n\nvoid function(Base1 *ptr){//一个指向父类的指针\n    ptr->display();\n}\n\nint main(){\n    Base1 b1;\n    Base2 b2;\n    function(&b1);//调用 void Base1::display() const\n    function(&b2);//调用 void Base2::display() const\n}\n```\n\n三种继承方式：父类成员对子类的可见性：\n\n| 父类访问控制/继承方式： | public    | protected | private |\n| ----------------------- | --------- | --------- | ------- |\n| public                  | public    | protected | private |\n| protected               | protected | protected | private |\n| private                 | private   | private   | private |\n\n\n\n## C++ Variable\n\n#### C++ Variable types:\n\n| Type        | Implication                                   | size                 |\n| ----------- | --------------------------------------------- | -------------------- |\n| bool        | bool type                                     | undefined            |\n| char        | character                                     | 8b                   |\n| wchar_t     | wide character                                | 16b                  |\n| char16_t    | Unicode character                             | 16b                  |\n| char32_t    | Unicode character                             | 32b                  |\n| short       | short integer                                 | 16b                  |\n| int         | integer                                       | 16b                  |\n| long        | long integer                                  | 32b                  |\n| long long   | long long integer                             | 64b                  |\n| float       | single-precision floating point number        | 6 significant digit  |\n| double      | double-precision floating point number        | 10 significant digit |\n| long double | expand double-precision floating point number | 10 significant digit |\n\nUse `unsigned` to state an unsigned variable type, an unsigned variable do not have a sign digit.\n\n#### Type conversion\n\n```c++\nbool a =42;// 0 refers true and the others refer false.\nint i =3.14;// the value of i is 3,the fractional digit has been dropped.\ndouble pi =i;//the value of pi is 3\nunsigned char c = -1; //the value of c is 255\n```\n\n`WARNING`: **DO NOT USE UNSIGNED TYPE AND  SIGNED TYPE VARIABLE AT THE SAME TIME !!!**\n\n#### Reference\n\n```c++\nint a=3;\nint &num = a;// num is a reference of a\nint &num2;//ERROR: reference must be initialized\n```\n\n#### Pointer\n\nPointers point to a pointer:\n\n```c++\nint a=1024;\nint *ptr1 = &a;\nint **ptr2 = &ptr1;\ncout<<**ptr2<<endl;// output 1024\n```\n\nC++ Standard Library :: begin, end\n\n```c++\nint ia[]={1,2,3,4,5,6,7,8,9};\nint *beg = begin(ia);//refer a[0]\nint *end = end(ia);//refer the next position after the last element of an array\n```\n\nPointer with custom size:\n\n```c++\nint a[2][2];\nint *p[2];//NOT THIS: It created a pointer array\nint (*p2)[2];//a pointer which can point to an array with 2 ints.\n//use decltype or auto:\ndecltype *p3 = a;\n```\n\n\n\n#### Const\n\nYou can use `const` to make a variable unchangeable.\n\n**Top-level-const and Low-level-const:**\n\n```c++\nint i=0;\nint *const p1 = &i;//the value of pointer can not be changed,top-level-const\nconst int ci =42;//the value of ci can not be changed.\nconst int *p2 = &ci;//the value of pointer can not be changed\n```\n\n#### Typedef\n\n```c++\ntypedef double wages;\n```\n\n#### Decltype\n\nUse decltype to get a type that a function returns.\n\n```c++\ndecltype(f()) sum =0;//the type of sum is just the type that f() returns.\n```\n\n#### Write your own head file\n\nYou'd better define your struct and class in a head file .\n\n## Data Structure(STL)\n\n#### Using statement\n\nBefore using C++ Standard Library, you can:\n\n```c++\n//method 1\nstd::cout<<\"Test\"<<std::endl;\n//method 2:\nusing namespace std;\ncout<<\"123\"<<endl;\n```\n\n\n\n#### Using iterator\n\nA sort of intelligence pointer , used for STD .\n\nC++ example:\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    vector<int> vec1;//Statement\n    for (int i = 0; i < 5; i++)\n    {\n        vec1.push_back(i);\n    }\n    auto it = vec1.begin();//Auto Statement\n    vector<int>:: iterator it = vec1.begin();//Standard statement\n\n    cout << *it << endl;\n    for (; it != vec1.end(); it++)\n    {\n        cout << *it << endl;\n    }\n    \n    return 0;\n    \n}\n```\n\nOperations:\n\n```c++\nit = v1.begin();//set v1 refer to the first\n*it;//return value\nit++;//point to the next\n*it = 1234;//change value\nit2 = it + 2;//send the address + 2 to another\n```\n\n\n\n#### Stack: a LIFO(Last in First out) data structure\n\nStatement in C++:\n\n```c++\nstack<int> stack_name;\n```\n\nBasic operations:\n\n```c++\nstack_name.push(data);//push a data into the stack\ncout<<stack_name.top();//read the data at top\nstack_name.pop();//pop out the data at top\n```\n\n#### Queue: a FIFO(First in First out) data structure\n\nStatement in C++:\n\n```c++\nqueue<int> q;\n```\n\nBasic operations:\n\n```c++\nq.front();//read the data at the front\nq.push();//push a data at the end of the queue\nq.pop();//pop out the data at the front\nq = queue<int>();//empty the queue\n```\n\nThen, let's see a sample of using queue.\n\nCruel torture (AHU77)\n\n------\n\nPlease read the question at [bofcOJ](oj.bofc.tech)\n\n------\n\nCode:\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int qty_children = 0, k;\n    cin >> qty_children >> k;\n\n    \n    int sum = 0;\n    queue<int> children;\n    for (int i = 1; i <= qty_children; i++)\n    {\n        children.push(i);\n    } //statement queue\n    while (sum < qty_children-1)\n    {\n\n        for (int i = 0; i < k-1; i++)\n        {\n            children.push(children.front());//if we do not pull out the line, thus we let this wild kid get to the back.\n            children.pop();\n        }\n        children.pop();//when it comes to pull out the line, this wild kid is over.\n        sum++;\n    }\n    cout << children.front();\n\n    return 0;\n}\n```\n\n\n\n#### Using dynamic array with pointer\n\nCode demo:\n\n```c++\nint *p = new int[10];//Create an array when running.\ndelete[] p;//the realease of a dynamic array method is not same with a variable\n```\n\n#### bitset\n\nA data structure which storages bit.\n\n```c++\n    bitset<4> bitset1;//construct without parameter:set space 4\n\n    bitset<8> bitset2(12);//the space is 8, storge 12 into binary system,use 0 to fill the blank bit.\n\n    string s = \"100101\";\n    bitset<10> bitset3(s);//the space is 10,use 0 to fill the blank bit,the string CAN ONLY CONTAINS 0 and 1.\n    \n    char s2[] = \"10101\";\n    bitset<13> bitset4(s2);//the space is 13,use 0 to fill the blank bit\n\n    cout << bitset1 << endl;//0000\n    cout << bitset2 << endl;//00001100\n    cout << bitset3 << endl;//0000100101\n    cout << bitset4 << endl;//0000000010101\n    bitset3[0];//Simular as array,use subscript to access the elements.\n    \n```\n\nThere's so many ways to use bitset, but let's see struct first.\n\n#### Struct\n\nA struct is a data structure which contains serval variable type. The struct can also form an array!\n\nC++ examples\n\n```c++\nstruct Books\n{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;\n} book = {\"C Language\", \"RUNOOB\", \"Programing Language\", 123456};//define a struct and initialize\n\n\n```\n\n//Of course, you can use it as below: No initialize.\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct student //define the struct of single student\n{\n    int number;\n    int score;\n};\n\nint main()\n{\n\tstudent students[10000];\n       for (int i = 0; i < total; i++) //input scores\n      {\n        cin >> students[i].number >> students[i].score;//See the examples here!\n      }\n\n    return 0;\n\n}\n//It means you can only define a struct and use it as a data type!\n```\n\n##### Struct pointer\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct student //define the struct of single student\n{\n    int number;\n    int score;\n};\n\nint main()\n{\n    struct student students[100];\n\n    scanf(\"%d%d\", &students[0].number, &students[0].score); //See the examples here!\n\n    struct student *p = students; //initialize the pointer.\n    printf(\"%d\", p->number);      \n    p++;                          //go to next student.\n    return 0;\n}\n\n```\n\n\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct student\n{\n    int id;\n    int maths;\n};\n\nint main()\n{\n    struct student stu1[2];\n    struct student *p ;\n    p=stu1;\n    \n    printf(\"%d\",p->id);\n\n    return 0;\n}\n```\n\n\n\n#### Vector\n\nThis is a significant data structure in  C++ standard library , equals an array that can change memory size at will,and you can also CRUD in it in will.\n\nBasic operations:\n\n```c++\nvector<int> c;\nc.push_back(1);//place the element at the end of the vector.\n\n```\n\n```c++\nvector<Sales_item> sales_vec;//vector can also store class or struct\nvector<vector<string>>;//the elements in this vector are also vector objects.\n```\n\nOther operations:\n\n```c++\nvector<T> v1{1,2,3,4,5};\nvector<T> v2(5,5);//{5,5,5,5,5}\nvector<string> v3={\"Hello\",\"World\",\"!\"};\nvector<int> v4(10); //Create a vector have 10 elements, initialized by 0.\nv4.push_back(1);//put an elemnet to the back of the vector;\nv4.size();\n```\n\nUse array to initialize a vector \n\n```c++\nint a[]={1,2,3,4,5};\nvector<int> v1(begin(a),end(arr));//send the begin and end to construct.\n```\n\n\n\n#### String\n\nString is a **char** sequence whose size is changeable .\n\nInitialize:\n\n```c++\nstring s1;//an empty string has been created\nstring s2(10,'c');//\"cccccccccc\"\n```\n\nOperations:\n\n| Operation | Action                          |\n| --------- | ------------------------------- |\n| os<<s;    | Write s to ostream              |\n| is>>s;    | Write instream to s             |\n| s.size(); | Return the length;              |\n| s1+s2     | Connect two strings             |\n| s1>=s2    | compare, use *dictionary order* |\n\n**Get line**\n\n```c++\nwhile(getline(cin,line)&&line.size()>0)\n{\n    //code\n}\n```\n\n**Character type:**\n\n```c++\ntolower(c);//change into lower size\ntoupper(c);//change into upper size\n```\n\n`Warning`: Do not do this:\n\n```c++\nchar a[]=\"fff\";\nchar b[]=\"aaa\";\nstring c = a+b;//ERROR: you are trying to add two pointers!!!\n```\n\n\n\n#### Set\n\nAn example:\n\n```c++\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int case_number;\n    cin >> case_number; //Input the amount\n    set<int> numbers;\n    int put_number;\n    set<int> :: iterator out_number;\n    for (int i = 0; i < case_number; i++) // Input data\n    {\n        cin >> put_number;\n        numbers.insert(put_number);\n    }\n    cout << numbers.size() << endl;\n    int count=0;\n    for (out_number = numbers.begin(); out_number != numbers.end(); out_number++) \n    {\n        \n        cout << *out_number ;\n        count++;\n        if(count <= numbers.size()-1) cout<<\" \";\n    }\n\n    return 0;\n}\n```\n\nSet can automatically sort, and the elements are strictly diverse .\n\n#### 优先队列:优先级最高的元素先出的队列\n\nC++的标准库中包含了一个很好用的数据结构:优先队列.该结构可以将优先级大的元素排到前面.\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tpriority_queue<int> que_apples; //默认使用vector,大的数字优先\n\tpriority_queue<int, vector<int>, greater<int>> app_que;//小的数字优先\n\t\n\treturn 0;\n}\n```\n\n自定义优先级:重载运算符\n\n```c++\nclass Student\n{\n    int id;\n    char name[20];\n    bool gender;\n    bool operator < (Student &a) const\n    {\n        return id > a.id;\n    }\n};\n```\n\n\n\n## STL算法\n\n#### 快排(sort),包含在algorithm\n\n这个算法极其牛逼,解放了万千程序员的双手(赞美)!!!\n\n快排作用的内容:数组/向量容器等\n\nC++使用实例\n\n```c++\nvector<int> v1;\nint numbers[2][5];\nstruct student\n{\n    int number;\n    int score;\n    string name;\n}\n//此处省略若干行插入数据代码,让我们假设这这里面有很多数据\nsort(v1.begin(),v1.end());//默认从小到大排列\nbool compare(int a , int b)//按某种排序方案排序\n{\n    return a>b;//这样是降序排列\n    return numbers[a][0]>numbers[b][0];//还能读取某些数据的元素排列\n    return student[a].score>student[b].score;//还能读取某些结构体的成员\n}\n```\n\n\n\n## 常用基础算法(一些很基本的,要背的)\n\n#### 公因数公倍数\n\n```c++\n#include <stdio.h>\n#include <math.h>\nint main()\n{\n    int m, n;\n    int s = 0;\n    int min = 0;\n    scanf(\"%d%d\", &m, &n);\n    //最大公约数\n    if (m > n)\n    {\n        s = m;\n        min = n;\n    }\n    else\n    {\n        s = n;\n        min = m;\n    }\n    while (min != 0)\n    {\n        int t = s%min;\n        s = min;\n        min = t;\n    }\n    printf(\"%d\\n\",s);\n    //重置两个数\n    if (m > n)\n    {\n        s = m;\n        min = n;\n    }\n    else\n    {\n        s = n;\n        min = m;\n    }\n    //公倍数\n    for (int i = min;; i += min)\n    {\n        double resR = (double)i / s;\n        int floor = i / s;\n\n        if ((double)floor == resR)\n        {\n            printf(\"%d\\n\", i);\n            break;\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n#### 筛法判断质数\n\n上代码:\n\n```c++\nbool isPrime(int a)\n{\n    if (a == 2)\n        return true;\n    if (a % 2 == 0)\n        return false;\n    int x = sqrt(a);\n    for (int i = 2; i <= x; ++i)\n    {\n        if (a % i == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n#### 素数的埃式筛法\n\n先确认一个数是素数,然后划掉其倍数,在找到下一个素数后,再划掉其倍数,最后只剩素数.\n\n```c++\nint main()\n{\n    int number_list[1000] = {0}; //we can get primes below 1000\n    bool break_flag = false;\n    number_list[0] = 1;\n    int pri = 2;\n    while (!break_flag)\n    {\n        // the non-prime will be mark 1\n        int count = pri;\n        while (count <= 1000)\n        {\n            count += pri;\n            if (count >= 1000)\n                break;\n            number_list[count] = 1;\n        }\n        int temp_pri = pri;\n        while (true)\n        {\n            temp_pri++;\n            if (temp_pri >= 999)\n            {\n                break_flag = true;\n                break;\n            }\n            if (number_list[temp_pri] == 0)\n            {\n                pri = temp_pri;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < 1000; i++)\n    {\n        if (number_list[i] == 0)\n        {\n            cout << i << \" \";\n        }\n    }\n\n    return 0;\n}\n```\n\n#### 分解质因数(简便方法)\n\n```c\n#include <stdio.h>\n#include <math.h>\n//这个程序适合好好阅读并分析\nvoid foo(long long int n)\n{\n    long long int sqr = sqrt(n);//测试质数只需测到平方的取整\n    long long int i = 0;\n    for(i = 2; i <= sqr; i++)//从2开始测\n    {\n        if(n % i == 0 && (n /= i))//后面的表达式指的是除i留下剩余部分\n        {\n            printf(\"%lld \", i--);\n        }\n    }\n    if(n != 1)//不打印1作为因子\n    {\n        printf(\"%lld\", n);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    long long int n ;\n    scanf(\"%lld\", &n);\n    foo(n);\n    return 0;\n}\n\n```\n\n\n\n#### 查找字符(这是C标准库里的内容)\n\n用于在一个字符串(也就是char数组)中查找指定的字符\n\n```c++\nstrchr(string_name, 'A');//在string name 这个字符串中寻找A这个字符\n//返回有多种可能,若找到,返回指向这个字符的指针,否则返回NULL(这个NULL是标识符,不是字符串之类的玩意)\n```\n\n#### 位运算\n\n位运算是一种直接操作位的运算,其包含多种运算符:\n\n上代码:\n\n```c++\n<<; //左移运算符,移动时丢弃左边的位,用0补充\n\"11110000\"<<\"10000000\";//左移了3位!!!\n>>; //右移运算符,移动时丢弃右边的位,左边用0或原来丢弃的左边的位补充!!!\n\"11111111\">>\"00001111\";//右移了四位!!!\n    \n//接下来看看逻辑位运算\n~;//按位非,倒置0/1\n|;//按位或,有一为1,否则为0\n^;//XOR,相同为0,不同为1\n&;//AND,都为1才为1,否则为0\n\n//一些常用的位逻辑运算:\nlottabits |= pow(2,3);//打开位,也就是将某一位置为1,其中后面的2的多少次方代表着打开的位置(2的0次方代表右起第一位,以此类推)\nlottabits ^= pow(2,3);//切换位:置反\nlottabits &= pow(2,3);//关闭位:置0\nbool isOpen = lottabits & pow(2,3);//测试某一位是否为1(打开),返回true or false.\n```\n\n"},"__N_SSG":true}