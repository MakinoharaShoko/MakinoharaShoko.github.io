{"pageProps":{"post":"---\nlayout:     post\ntitle:      WASM + Rust + WebWorker 实现计算器（\nintro:   \"\"\ndate:       2022-4-8 23:00:00\nauthor:     \"Mahiru\"\ncatalog: true\ntags:\n    - 工程开发\n---\n\n## WASM + Rust + WebWorker 实现高性能计算器\n\n假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。\n\n而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。\n\n**本文就将实现在 Web Worker 中调用 WASM 进行运算。**\n\n首先，我们来编写一段 Rust 代码，用于完成实际的计算。\n\n```rust\nextern crate wasm_bindgen;\n\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern \"C\" {}\n\n#[wasm_bindgen]\npub fn wasm_add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。\n\n接下来，我们需要创建一个网页，用于测试我们的函数。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>TestWoker</title>\n</head>\n<body>\n<script type=\"module\" src=\"script.js\"></script>\n</body>\n</html>\n```\n\n在 `script.js`里面，我们要创建一个 Web Worker。\n\n```js\nif (window.Worker) {\n    //加载worker，注意第二个参数要有，否则无法导入 module\n    const myWorker = new Worker('./worker.js', {type: 'module'});\n    myWorker.postMessage([1, 2]);//发送消息\n    myWorker.postMessage([3, 4]);//发送消息\n    setTimeout(() => {\n        myWorker.postMessage([7, 8])\n    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。\n    myWorker.onmessage = (m) => {\n        const data = m.data;\n        console.log('data from wasm: ' + data); //拿到 wasm 计算的结果\n    }\n}\n```\n\n然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。\n\n```js\nimport init from './pkg/hello_wasm.js';\nimport {wasm_add} from './pkg/hello_wasm.js';\n\nlet isWasmInit = false; //判断是否完成wasm编译\n\ninit().then(() => isWasmInit = true); //初始化Wasm（编译）\n\nonmessage = function (m) {\n    const data = m.data;\n    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。\n        console.log('Wasm init before message');\n        run();\n    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。\n        console.log('Wasm not init before message');\n        init().then(() => {\n                run();\n                isWasmInit = true;\n            }\n        );\n    }\n\n    function run() {\n        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数\n        postMessage(res);\n    }\n}\n```\n\n这样，我们就实现了一个**不阻塞主线程的，高性能**的加法。（好像没有什么卵用\n\n但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？\n"},"__N_SSG":true}