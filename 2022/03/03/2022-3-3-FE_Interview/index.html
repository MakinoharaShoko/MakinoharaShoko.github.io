<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MSFASR</title>
    
<link rel="stylesheet" href="/css/osx.css">

    
<link rel="stylesheet" href="/css/aside.css">

    
<link rel="stylesheet" href="/css/index.css">

    
<link rel="stylesheet" href="/css/post.css">

    
<link rel="stylesheet" href="/css/tags.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    <!-- 这是引入样式-->


    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>




<meta name="generator" content="Hexo 4.2.0"></head>




<body >

<div class="Finder">
    &nbsp; &nbsp;

<!--    <img src="/img/title-logo_s.png"  alt="apple" id="Apple"/>-->
    <a href="/" id="logo-text" class="FinderText">&nbsp k@M0me’s Humble Abode &nbsp</a>
    <span>
        &nbsp;&nbsp;
    </span>
    <a  href="/" id="blog" class="FinderText">&nbsp博&nbsp&nbsp客&nbsp
<!--        <div id="blogMenu" class="MenuDiv">-->
<!--            <div id="mainpage" class="menuText" >-->
<!--             <a href="/" class="post-url">主页</a>-->
<!--            </div>-->
<!--            <div id="catagory"class="menuText">-->
<!--                <a href="/tags/生活感想" class="post-url">归档</a>-->
<!--            </div>-->
<!--            <div id="archieves" class="menuText">-->
<!--                <a href="/archives" class="post-url">时间线</a>-->
<!--            </div>-->
<!--            <div id="photo" class="menuText">-->
<!--                <a href="/photos" class="post-url">照片墙</a>-->
<!--            </div>-->
<!--        </div>-->
    </a>
    <a href="/archives/2019/08/" id="timeline" class="FinderText">&nbsp时&nbsp间&nbsp线&nbsp</a>
    <a href="/tags/计算机基础" id="cate" class="FinderText">&nbsp归&nbsp&nbsp档&nbsp</a>
    <a href="/aboutNew" id="about" class="FinderText">&nbsp关&nbsp于&nbsp与&nbsp友&nbsp链</a>
<!--    <div id="control" class="FinderText">&nbsp控制&nbsp-->
<!--        <div id="controlMenu"class="MenuDiv">-->
<!--            <div id="backToTop" class="menuText">-->
<!--                <a href="#Showtags" class="post-url">返回顶部</a>-->
<!--            </div>-->
<!--            <div  class="menuText">-->
<!--                <a href="-->
<!--        http://msfasr.com/2022/04/06/2022-4-6-Wasm/-->
<!--        " class="post-url">上一篇-->
<!--                    </a>-->
<!--            </div>-->
<!--            <div  class="menuText">-->
<!--                <a href="-->
<!--        http://msfasr.com/2022/03/03/2022-3-3-Socket/-->
<!--        " class="post-url">下一篇</a>-->
<!--            </div>-->


<!--        </div></div>-->
<!--    <div id="options" class="FinderText">&nbsp选项&nbsp-->
<!--        <div id="optionsMenu"class="MenuDiv">-->
<!--            <div id="share" class="menuText">-->
<!--                <a href="" class="post-url" id="shareThisPage">分享本页</a>-->
<!--            </div>-->

<!--        </div></div>-->
<!--    <div id="about" class="FinderText">&nbsp关于&nbsp-->
<!--        <div id="aboutMenu"class="MenuDiv">-->

<!--            <div id="aboutMain" class="menuText">-->
<!--                <a href="/2019/08/20/About/" class="post-url">个人简介</a>-->
<!--            </div>-->
<!--            <div  class="menuText">-->
<!--                <a href="/2019/08/20/links/" class="post-url">友情链接</a>-->
<!--            </div>-->

<!--            <div  class="menuText">-->
<!--                <a href="mailto:makinoharashoko@outlook.com" class="post-url">邮箱</a>-->
<!--            </div>-->
<!--            <div  class="menuText">-->
<!--                <a href="https://github.com/MakinoharaShoko" target="_blank" rel="noopener" class="post-url">Github</a>-->
<!--            </div>-->
<!--            <div id="twitter"  class="menuText">-->
<!--                <a href="https://twitter.com/_Makinohara" target="_blank" rel="noopener" class="post-url">Twitter</a>-->
<!--            </div>-->

<!--            <div  class="menuText">-->
<!--                <a href="https://github.com/MakinoharaShoko/hexo-OSX-theme" target="_blank" rel="noopener" class="post-url">Theme OS-X by Makinohara</a>-->
<!--            </div>-->
<!--            <div id="author" class="menuText">-->
<!--                <a href="/" class="post-url">©2020 MSFASR Centre Telecom</a>-->
<!--            </div>-->
<!--        </div><nbsp></nbsp></div>-->
<!--    <img src="/img/iconsTop.png" alt="icons"id="icons"/>-->
<!--    <div id="showtime"></div>-->

</div>

<!--now write body-->
<div id="body">
    
<link rel="stylesheet" href="/css/aside.css">


<div id="Content">
    <!-- 引入侧边栏 -->
    <div id="asidePart">
        <nav id="title-list-nav">
            
                <a  class="post-url"
                   href="/2022/04/08/2022-4-8-Wasm-2/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-04-08 23:00:00">2022/04/08</div>
                        <div class="post-title" title="WASM + Rust + WebWorker 实现计算器（">WASM + Rust + WebWorker 实现计算器（</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2022/04/06/2022-4-6-Wasm/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-04-06 23:00:00">2022/04/06</div>
                        <div class="post-title" title="WASM Rust 踩坑记（附完整解决方法">WASM Rust 踩坑记（附完整解决方法</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2022/03/03/2022-3-3-FE_Interview/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-03-03 23:00:00">2022/03/03</div>
                        <div class="post-title" title="前端面试知识点查缺补漏">前端面试知识点查缺补漏</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2022/03/03/2022-3-3-Socket/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-03-03 23:00:00">2022/03/03</div>
                        <div class="post-title" title="WebSocket 与 Socket.io 总结">WebSocket 与 Socket.io 总结</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2022/02/23/2022-2-23-CORS/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-02-23 23:00:00">2022/02/23</div>
                        <div class="post-title" title="有关跨域问题的知识点概述">有关跨域问题的知识点概述</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2022/02/11/2022-2-11-YouthCamp/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2022-02-11 23:00:00">2022/02/11</div>
                        <div class="post-title" title="关于参加字节跳动前端冬季青训营的总结">关于参加字节跳动前端冬季青训营的总结</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/12/18/2021-12-18-Redux1/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-12-18 12:00:01">2021/12/18</div>
                        <div class="post-title" title="Redux初体验">Redux初体验</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/12/14/2021-12-14-FE_List/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-12-14 12:00:01">2021/12/14</div>
                        <div class="post-title" title="前端学习拉清单">前端学习拉清单</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/11/02/2021-11-2-JavaScript2/"
                   data-tag="编程语言"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-11-02 08:00:00">2021/11/02</div>
                        <div class="post-title" title="JavaScript高级程序设计">JavaScript高级程序设计</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/10/24/2021-10-24-WG_3/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-10-24 12:00:01">2021/10/24</div>
                        <div class="post-title" title="记一次前端项目的踩坑与开发经验">记一次前端项目的踩坑与开发经验</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/09/27/2021-9-27-WG_1/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-09-27 12:00:01">2021/09/27</div>
                        <div class="post-title" title="WebGAL开发日志1：我如何打造一个网页版的Galgame游戏引擎">WebGAL开发日志1：我如何打造一个网页版的Galgame游戏引擎</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/09/17/2021-9-17-React/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-09-17 12:00:01">2021/09/17</div>
                        <div class="post-title" title="React">React</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/09/12/2021-9-12-nodeJs/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-09-12 12:00:01">2021/09/12</div>
                        <div class="post-title" title="Node.js">Node.js</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/08/03/2021-8-3-ML/"
                   data-tag="科研应用"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-08-03 12:00:01">2021/08/03</div>
                        <div class="post-title" title="机器学习">机器学习</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/07/09/2021-7-9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%A4%8D%E4%B9%A0/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-07-09 21:00:01">2021/07/09</div>
                        <div class="post-title" title="计算机组成复习">计算机组成复习</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/07/07/2021-7-7-%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%81%93%E5%BE%B7/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-07-07 16:00:01">2021/07/07</div>
                        <div class="post-title" title="没有什么道德">没有什么道德</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/07/06/2021-7-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-07-06 21:00:01">2021/07/06</div>
                        <div class="post-title" title="操作系统复习">操作系统复习</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/07/01/2021-7-1-sql/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-07-01 21:00:01">2021/07/01</div>
                        <div class="post-title" title="数据库复习">数据库复习</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/07/01/2021-7-1-TestLatex/"
                   data-tag="学习"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-07-01 12:00:01">2021/07/01</div>
                        <div class="post-title" title="测试公式输入">测试公式输入</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/06/30/2021-6-30-ZX/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-06-30 12:00:01">2021/06/30</div>
                        <div class="post-title" title="大学贰年自省录">大学贰年自省录</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/06/16/2021-6-16-CV/"
                   data-tag="科研应用"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-06-16 12:00:01">2021/06/16</div>
                        <div class="post-title" title="计算机视觉——入门">计算机视觉——入门</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2021/03/20/2021-3-23-Maven/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2021-03-20 12:00:00">2021/03/20</div>
                        <div class="post-title" title="Maven">Maven</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/05/08/2020-5-8-ASR-E1/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-05-08 11:00:00">2020/05/08</div>
                        <div class="post-title" title="KMP算法详解">KMP算法详解</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/04/15/2020-3-24-Reduce/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-04-15 23:00:00">2020/04/15</div>
                        <div class="post-title" title="论手机是如何改变我们的思维方式的">论手机是如何改变我们的思维方式的</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/24/2020-2-24-HowToWeb/"
                   data-tag="生活感想,工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-24 14:00:00">2020/02/24</div>
                        <div class="post-title" title="如何成为Web工程师">如何成为Web工程师</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/18/2020-2-18-Web/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-18 09:00:00">2020/02/18</div>
                        <div class="post-title" title="Web开发基础">Web开发基础</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/17/2020-2-17-Algorithm/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-17 16:13:00">2020/02/17</div>
                        <div class="post-title" title="算法分析（基础篇）">算法分析（基础篇）</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/17/2020-2-17-Data2/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-17 16:13:00">2020/02/17</div>
                        <div class="post-title" title="数据结构2：树、散列、堆、图">数据结构2：树、散列、堆、图</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/17/2020-2-17-Data1/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-17 16:13:00">2020/02/17</div>
                        <div class="post-title" title="数据结构1:表、栈和队列">数据结构1:表、栈和队列</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/02/16/2020-2-16-DevelopingTheme/"
                   data-tag="工程开发"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-02-16 13:13:00">2020/02/16</div>
                        <div class="post-title" title="开发自己的Hexo主题">开发自己的Hexo主题</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2020/01/20/2020-1-20-Programmer's%20advancement/"
                   data-tag="生活感想,计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2020-01-20 23:13:00">2020/01/20</div>
                        <div class="post-title" title="(转载)程序员修炼之路">(转载)程序员修炼之路</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/12/27/2019-12-27-19End/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-12-27 23:13:00">2019/12/27</div>
                        <div class="post-title" title="To the end of 2019.">To the end of 2019.</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/11/26/2019-11-26-Linux/"
                   data-tag="计算机基础"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-11-26 08:00:00">2019/11/26</div>
                        <div class="post-title" title="How to use Linux">How to use Linux</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/11/19/2019-11-19-Cpp/"
                   data-tag="编程语言"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-11-19 16:00:00">2019/11/19</div>
                        <div class="post-title" title="C++语言学习笔记">C++语言学习笔记</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/11/12/2019-11-12-C/"
                   data-tag="编程语言"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-11-12 10:13:00">2019/11/12</div>
                        <div class="post-title" title="C Programing Language">C Programing Language</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/11/10/2019-11-10-SaveMaths/"
                   data-tag="学习"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-11-10 15:13:00">2019/11/10</div>
                        <div class="post-title" title="如何拯救我的数学">如何拯救我的数学</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/10/25/2019-10-25-Java/"
                   data-tag="编程语言"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-10-25 08:00:00">2019/10/25</div>
                        <div class="post-title" title="Developing in Java">Developing in Java</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/10/25/2019-10-25-Python/"
                   data-tag="编程语言"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-10-25 08:00:00">2019/10/25</div>
                        <div class="post-title" title="Developing in Python">Developing in Python</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/10/03/2019-10-03-Chinese%20Phone/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-10-03 12:00:00">2019/10/03</div>
                        <div class="post-title" title="重返国产机">重返国产机</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/09/30/2019-09-30-Hello%202019/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-09-30 12:00:00">2019/09/30</div>
                        <div class="post-title" title="Hello 2019">Hello 2019</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/09/30/2019-09-30-OneYearLater/"
                   data-tag="生活感想"
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-09-30 12:00:00">2019/09/30</div>
                        <div class="post-title" title="TO: YOU. ONE YEAR LATER">TO: YOU. ONE YEAR LATER</div>
                    </div>

                </a>
            
                <a  class="post-url"
                   href="/2019/08/20/About/"
                   data-tag=""
                   data-author="" >
                    <div class="post-box">

                        <div class="post-date" title="2019-08-20 21:59:02">2019/08/20</div>
                        <div class="post-title" title="About">About</div>
                    </div>

                </a>
            
        </nav>
    </div>

    <div id="content">

        <div class="ArticleHead">
            <div id="Showtags">
                
                    
                    
                        <a href='/tags/工程开发/'>
                            <div class="singleTag">
                                工程开发
                            </div>
                        </a>
                    
                
            </div>
            <br/>
            <br/>
            <br/>
            <div class="ArticleText">
                前端面试知识点查缺补漏
            </div>
            <div class="ArticleTime">
                Published on Thu Mar 03 2022 23:00:00 GMT+0000
            </div>


        </div>
        <div id="article">
            <h1 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h1><h2 id="JS延迟加载"><a href="#JS延迟加载" class="headerlink" title="JS延迟加载"></a>JS延迟加载</h2><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p>
<p>我了解到的几种方式是：</p>
<p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>
<p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p>
<p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p>
<p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h3 id="事件循环的基本原理"><a href="#事件循环的基本原理" class="headerlink" title="事件循环的基本原理"></a>事件循环的基本原理</h3><ol>
<li>从 <strong>宏任务</strong> 队列（例如 “script”）中出队（dequeue）并执行最早的任务。</li>
<li>执行所有微任务：<ul>
<li>当微任务队列非空时：<ul>
<li>出队（dequeue）并执行最早的微任务。</li>
</ul>
</li>
</ul>
</li>
<li>如果有变更，则将变更渲染出来。</li>
<li>如果宏任务队列为空，则休眠直到出现宏任务。</li>
<li>转到步骤 1。</li>
</ol>
<p>安排（schedule）一个新的 <strong>宏任务</strong>：</p>
<ul>
<li>使用零延迟的 <code>setTimeout(f)</code>。</li>
</ul>
<p>它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。</p>
<p>此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。</p>
<p>安排一个新的 <strong>微任务</strong>：</p>
<ul>
<li>使用 <code>queueMicrotask(f)</code>。</li>
<li>promise 处理程序也会通过微任务队列。</li>
</ul>
<p>在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。</p>
<p>所以，我们可以使用 <code>queueMicrotask</code> 来在保持环境状态一致的情况下，异步地执行一个函数。</p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><ul>
<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它。</li>
<li>当用户移动鼠标时，任务就是派生出 <code>mousemove</code> 事件和执行处理程序。</li>
<li>当安排的（scheduled）<code>setTimeout</code> 时间到达时，任务就是执行其回调。</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</p>
<h2 id="Promise-与-异步编程"><a href="#Promise-与-异步编程" class="headerlink" title="Promise 与 异步编程"></a>Promise 与 异步编程</h2><h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><p>没有实现链式调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(func) &#123;<br>        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'PENDING'</span>; <span class="hljs-comment">// 初始化状态</span><br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 成功返回的值</span><br>        <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">//失败返回的值</span><br><br>        <span class="hljs-keyword">this</span>.callbacks = [];<span class="hljs-comment">//结束后的回调</span><br>        func(<span class="hljs-keyword">this</span>.resolve.bind(<span class="hljs-keyword">this</span>), <span class="hljs-keyword">this</span>.reject.bind(<span class="hljs-keyword">this</span>));<span class="hljs-comment">//绑定this</span><br>    &#125;<br><br>    resolve(value) &#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'FULFILLED'</span>; <span class="hljs-comment">// 设置状态</span><br><br>        <span class="hljs-comment">// 通知事件执行</span><br>        <span class="hljs-keyword">this</span>.callbacks.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-keyword">this</span>._handler(cb));<br>    &#125;<br><br>    reject(reason) &#123;<br>        <span class="hljs-keyword">this</span>.reason = reason;<br>        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'REJECTED'</span>; <span class="hljs-comment">// 设置状态</span><br><br>        <span class="hljs-comment">// 通知事件执行</span><br>        <span class="hljs-keyword">this</span>.callbacks.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-keyword">this</span>._handler(cb));<br>    &#125;<br><br>    then(onFulfilled, onRejected) &#123; <span class="hljs-comment">//这个函数用于注册</span><br>        <span class="hljs-comment">// 将需要执行的回调函数存储起来</span><br>        <span class="hljs-keyword">this</span>.callbacks.push(&#123;<br>            onFulfilled,<br>            onRejected,<br>        &#125;);<span class="hljs-comment">//保存参数</span><br>    &#125;<br><br>    <span class="hljs-comment">//用于执行回调函数</span><br>    _handler(callback) &#123;<br>        <span class="hljs-keyword">const</span> &#123; onFulfilled, onRejected &#125; = callback;<span class="hljs-comment">//回调函数的两个参数</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'FULFILLED'</span> &amp;&amp; onFulfilled) &#123;<br>            <span class="hljs-comment">// 传入存储的值</span><br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'REJECTED'</span> &amp;&amp; onRejected) &#123;<br>            <span class="hljs-comment">// 传入存储的错误信息</span><br>            onRejected(<span class="hljs-keyword">this</span>.reason);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">success</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (success) &#123;<br>                res(<span class="hljs-string">"willem"</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rej(<span class="hljs-string">'error'</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;)<br>&#125;<br><br>test(<span class="hljs-literal">true</span>).then(<span class="hljs-function">(<span class="hljs-params">r, j</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(r);<br>&#125;)<br><br>test(<span class="hljs-literal">false</span>).then(<span class="hljs-literal">null</span>, j =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(j);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="手写-Promise-all-Promise-race"><a href="#手写-Promise-all-Promise-race" class="headerlink" title="手写 Promise.all Promise.race"></a>手写 Promise.all Promise.race</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">MyAll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterator</span>) </span>&#123;  <br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-comment">//用于计数，当等于len时就resolve</span><br>    <span class="hljs-keyword">let</span> len = iterator.length<br>    <span class="hljs-keyword">let</span> res = []<span class="hljs-comment">//用于存放结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> iterator)&#123;<br>            <span class="hljs-comment">//Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。</span><br>            <span class="hljs-comment">//如果这个值是一个 promise ，那么将返回这个 promise。</span><br>            <span class="hljs-built_in">Promise</span>.resolve(e)<span class="hljs-comment">//转化为Promise对象</span><br>            .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                res[count] = data;<br>                <span class="hljs-keyword">if</span>(++count === len)&#123;<br>                    resolve(res)<br>                &#125;<br>            &#125;)<br>            .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>                reject(e)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">MyRace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">iterator</span>) </span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> iterator)&#123;<br>            <span class="hljs-built_in">Promise</span>.resolve(e)<br>            .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                    resolve(data)<br>            &#125;)<br>            .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>                reject(e)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h3><h4 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span><span class="hljs-params">([param[, param[, <span class="hljs-rest_arg">... param</span>]]])</span> </span>&#123;<br>    statements <br>&#125;<br></code></pre></td></tr></table></figure>

<p>async函数一定会返回一个promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>如下代码:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">async <span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-type">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-type">Promise.resolve(1)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>async函数的函数体可以被看作是由0个或者多个await表达式分割开来的。从第一行代码直到（并包括）第一个await表达式（如果有的话）都是同步运行的。这样的话，一个不含await表达式的async函数是会同步运行的。然而，如果函数体内有一个await表达式，async函数就一定会异步执行。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">await</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">undefined</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h4><p><code>[返回值] = await 表达式;</code></p>
<p><code>await</code> 操作符用于等待一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 对象。它只能在异步函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async function</code></a> 中使用。</p>
<p>await 表达式会暂停当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async function</code></a> 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async function</code></a>。</p>
<p>若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。</p>
<p>另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      resolve(x);<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">await</span> resolveAfter2Seconds(<span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 10</span><br>&#125;<br>f1();<br></code></pre></td></tr></table></figure>

<h2 id="JS-函数"><a href="#JS-函数" class="headerlink" title="JS 函数"></a>JS 函数</h2><h3 id="详解-bind-apply-call"><a href="#详解-bind-apply-call" class="headerlink" title="详解 bind apply call"></a>详解 bind apply call</h3><h4 id="bind-绑定-this-指向"><a href="#bind-绑定-this-指向" class="headerlink" title="bind:绑定 this 指向"></a>bind:绑定 this 指向</h4><p><code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p>**<code>bind()</code> **方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">getX</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> unboundGetX = <span class="hljs-built_in">module</span>.getX;<br><span class="hljs-built_in">console</span>.log(unboundGetX()); <span class="hljs-comment">// The function gets invoked at the global scope</span><br><span class="hljs-comment">// expected output: undefined</span><br><br><span class="hljs-keyword">const</span> boundGetX = unboundGetX.bind(<span class="hljs-built_in">module</span>);<br><span class="hljs-built_in">console</span>.log(boundGetX());<br><span class="hljs-comment">// expected output: 42</span><br></code></pre></td></tr></table></figure>

<h4 id="apply-调用一个函数，接受参数数组"><a href="#apply-调用一个函数，接受参数数组" class="headerlink" title="apply:    调用一个函数，接受参数数组"></a>apply:    调用一个函数，接受参数数组</h4><p><code>func.apply(thisArg, [argsArray])</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> func1 = <span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hello,<span class="hljs-subst">$&#123;a&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">//apply接受一个参数数组</span><br>func1.apply(<span class="hljs-literal">null</span>,[<span class="hljs-string">'Mahiru'</span>])<br><span class="hljs-comment">//如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</span><br></code></pre></td></tr></table></figure>

<h4 id="call：调用一个函数，接受参数"><a href="#call：调用一个函数，接受参数" class="headerlink" title="call：调用一个函数，接受参数"></a>call：调用一个函数，接受参数</h4><p><code>function.call(thisArg, arg1, arg2, ...)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Product</span>(<span class="hljs-params">name, price</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  <span class="hljs-keyword">this</span>.price = price;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Food</span>(<span class="hljs-params">name, price</span>) </span>&#123;<br>  Product.call(<span class="hljs-keyword">this</span>, name, price);<br>  <span class="hljs-keyword">this</span>.category = <span class="hljs-string">'food'</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Food(<span class="hljs-string">'cheese'</span>, <span class="hljs-number">5</span>).name);<br><span class="hljs-comment">// expected output: "cheese"</span><br></code></pre></td></tr></table></figure>

<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><img src="https://user-images.githubusercontent.com/30483415/156961492-e97cd912-074c-4b8e-b99f-70dbd2eff676.jpg" alt="js__proto__"></p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p>手写 <code>instanceof</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">obj, obj2</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> proto = obj.__proto__;<br>    <span class="hljs-keyword">let</span> prototype = obj2.prototype;<br>    <span class="hljs-keyword">let</span> queue = [proto];<br>    <span class="hljs-comment">// 循环 obj 原型链进行获取 __proto__ 与 prototype 对比</span><br>    <span class="hljs-keyword">while</span>(queue.length) &#123;<br>        <span class="hljs-keyword">let</span> temp = queue.shift();<br>        <span class="hljs-keyword">if</span>(temp === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//找到原型链顶端，仍不是</span><br>        <span class="hljs-keyword">if</span>(temp === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue.push(temp.__proto__);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>当执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> Foo();<br></code></pre></td></tr></table></figure>

<p>JavaScript 实际上执行的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o.__proto__ = Foo.prototype;<br>Foo.call(o);<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">F</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> result = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> arg = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将实例对象的 __proto__ 指向 F.prototype</span><br>    <span class="hljs-built_in">Object</span>.setPrototypeOf(result, F.prototype);<br>    <span class="hljs-comment">// this 指向实例对象</span><br>    F.apply(result, arg);<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p><code>...</code></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y, z</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y + z;<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">console</span>.log(sum(...numbers));<br><span class="hljs-comment">// expected output: 6</span><br></code></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr1 = [...arr2, ...arr1]; <span class="hljs-comment">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span><br></code></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">'baz'</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">13</span> &#125;;<br><br><span class="hljs-keyword">var</span> clonedObj = &#123; ...obj1 &#125;;<br><span class="hljs-comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span><br><br><span class="hljs-keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;<br><span class="hljs-comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, ...theArgs</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">multiplier, ...theArgs</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> theArgs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> multiplier * element;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure>

<h2 id="对象的更多方法（待完善）"><a href="#对象的更多方法（待完善）" class="headerlink" title="对象的更多方法（待完善）"></a>对象的更多方法（待完善）</h2><p>Object.assign</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON法"><a href="#JSON法" class="headerlink" title="JSON法"></a>JSON法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1));<br></code></pre></td></tr></table></figure>

<h3 id="递归拷贝"><a href="#递归拷贝" class="headerlink" title="递归拷贝"></a>递归拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">initalObj, finalObj</span>) </span>&#123;    <br>  <span class="hljs-keyword">var</span> obj = finalObj || &#123;&#125;;    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> initalObj) &#123;        <br>    <span class="hljs-keyword">var</span> prop = initalObj[i];<span class="hljs-comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span><br>    <span class="hljs-keyword">if</span>(prop === obj) &#123;            <br>      <span class="hljs-keyword">continue</span>;<br>    &#125;        <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> prop === <span class="hljs-string">'object'</span>) &#123;<br>      obj[i] = (prop.constructor === <span class="hljs-built_in">Array</span>) ? [] : &#123;&#125;;            <br>      <span class="hljs-built_in">arguments</span>.callee(prop, obj[i]);<span class="hljs-comment">//调用自身，现在不建议用了</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj[i] = prop;<br>    &#125;<br>  &#125;    <br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">initalObj, finalObj</span>) </span>&#123;    <br>  <span class="hljs-keyword">var</span> obj = finalObj || &#123;&#125;;    <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> initalObj) &#123;        <br>    <span class="hljs-keyword">var</span> prop = initalObj[i];        <span class="hljs-comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span><br>    <span class="hljs-keyword">if</span>(prop === obj) &#123;            <br>      <span class="hljs-keyword">continue</span>;<br>    &#125;        <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> prop === <span class="hljs-string">'object'</span>) &#123;<br>      obj[i] = (prop.constructor === <span class="hljs-built_in">Array</span>) ? [] : <span class="hljs-built_in">Object</span>.create(prop);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj[i] = prop;<br>    &#125;<br>  &#125;    <br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> loadash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = loadash.cloneDeep(obj1);<br></code></pre></td></tr></table></figure>

<h2 id="闭包与高阶函数"><a href="#闭包与高阶函数" class="headerlink" title="闭包与高阶函数"></a>闭包与高阶函数</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeFunc</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Mozilla"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">var</span> myFunc = makeFunc();<br>myFunc();<br></code></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<ul>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
</ul>
<h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 保存this指向</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>; <span class="hljs-comment">// 拿到event对象</span><br><br>        clearTimeout(timeout)<br>        timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            func.apply(context, args)<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-keyword">if</span>(!valid)&#123;<br>           <span class="hljs-comment">//休息时间 暂不接客</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span><br>        valid = <span class="hljs-literal">false</span><br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            fn()<br>            valid = <span class="hljs-literal">true</span>;<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="柯里化与逆柯里化"><a href="#柯里化与逆柯里化" class="headerlink" title="柯里化与逆柯里化"></a>柯里化与逆柯里化</h4><h5 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func</span>) </span>&#123;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= func.length) &#123;<br>      <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> curried.apply(<span class="hljs-keyword">this</span>, args.concat(args2));<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="逆柯里化"><a href="#逆柯里化" class="headerlink" title="逆柯里化"></a>逆柯里化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unCurrying</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> tar = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...argu</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> fn.apply(tar, argu)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>
<p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。</p>
<p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p>
<p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>
<h2 id="JS-事件模型"><a href="#JS-事件模型" class="headerlink" title="JS 事件模型"></a>JS 事件模型</h2><h3 id="事件监听函数"><a href="#事件监听函数" class="headerlink" title="事件监听函数"></a>事件监听函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">addEventListener(eventType, handler, useCapture)<br></code></pre></td></tr></table></figure>

<h3 id="事件对象常用属性"><a href="#事件对象常用属性" class="headerlink" title="事件对象常用属性"></a>事件对象常用属性</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type用于获取事件类型<br><br>target获取事件目标<br><br><span class="hljs-function"><span class="hljs-title">stopPropagation</span><span class="hljs-params">()</span></span>阻止事件冒泡<br><br><span class="hljs-function"><span class="hljs-title">preventDefault</span><span class="hljs-params">()</span></span>阻止事件默认行为<br></code></pre></td></tr></table></figure>

<h3 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段"></a>事件阶段</h3><p>捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段</p>
<h3 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h3><p>事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p>
<p>如何将处于冒泡阶段的事件修改成捕获阶段呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">parent.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; &#123;      <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent 被点击了'</span>);   <br>&#125;，<span class="hljs-literal">true</span>)    <br>child.addEventListener(<span class="hljs-string">'click'</span>, (event) =&gt; &#123;     <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'child 被点击了'</span>);          <br>&#125;,<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<p>当处于冒泡阶段时，我们没有必要加第三个参数，因为 <code>addEventListener</code> 默认第三个参数为false（第三个参数存在），如果我们要事件处于捕获阶段的话，只要将第三个参数设成true就行。</p>
<h3 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h3><p>事件到达目标元素, 触发目标元素的监听函数。</p>
<h3 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h3><p>事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</p>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>事件在冒泡过程中会上传到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理(Event delegation)。</p>
<h3 id="target-currentTarget"><a href="#target-currentTarget" class="headerlink" title="target currentTarget"></a>target currentTarget</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noopener"><code>Event</code></a> 接口的只读属性 <code>currentTarget</code> 表示的是当事件沿着 DOM 触发时事件的当前目标。它总是指向事件绑定的元素，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target" target="_blank" rel="noopener"><code>Event.target</code></a> 则是事件触发的元素。</p>
<h2 id="Map-与-WeakMap"><a href="#Map-与-WeakMap" class="headerlink" title="Map 与 WeakMap"></a>Map 与 WeakMap</h2><p><code>WeakMap</code> 对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用（对对象的弱引用是指当该对象应该被 <code>GC</code> 回收时不会阻止 <code>GC</code> 的回收行为）。</p>
<p><code>Map</code> 相对于 <code>WeakMap</code> ：</p>
<ul>
<li><code>Map</code> 的键可以是任意类型，<code>WeakMap</code> 只接受对象作为键（null除外），不接受其他类型的值作为键</li>
<li><code>Map</code> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； <code>WeakMap</code> 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的</li>
<li><code>Map</code> 可以被遍历， <code>WeakMap</code> 不能被遍历</li>
</ul>
<h2 id="关于-Array"><a href="#关于-Array" class="headerlink" title="关于 Array"></a>关于 Array</h2><h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map Reduce"></a>Map Reduce</h3><p><strong>1.reduce是一个累加方法，是对数组累积执行回调函数，返回最终计算结果。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">array.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total, currentValue, currentIndex, arr</span>)</span>&#123;<br>&#125;, initialValue);<br><br><span class="hljs-comment">//total 必需。初始值, 或者计算结束后的返回值。</span><br><span class="hljs-comment">//currentValue  必需。当前元素</span><br><span class="hljs-comment">//currentIndex  可选。当前元素的索引</span><br><span class="hljs-comment">//arr   可选。当前元素所属的数组对象。</span><br><span class="hljs-comment">//initialValue可选。传递给函数的初始值</span><br></code></pre></td></tr></table></figure>

<p><strong>2.map是遍历数组的每一项，并执行回调函数的操作，返回一个对每一项进行操作后的新数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">array.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue,index,arr</span>), <span class="hljs-title">thisValue</span>)；<br>//<span class="hljs-title">currentValue</span>  必须。当前元素的值<br>//<span class="hljs-title">index</span> 可选。当前元素的索引值<br>//<span class="hljs-title">arr</span>   可选。当前元素属于的数组对象<br>//<span class="hljs-title">thisValue</span>可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="hljs-title">this</span>" 的值。如果省略了 <span class="hljs-title">thisValue</span>，或者传入 <span class="hljs-title">null</span>、<span class="hljs-title">undefined</span>，那么回调函数的 <span class="hljs-title">this</span> 为全局对象。</span><br></code></pre></td></tr></table></figure>

<p><strong>3.forEach和map用法一样,也是是遍历数组的每一项，并执行回调函数的操作，不过forEachf返回值是undefined，不可以链式调用。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), <span class="hljs-title">thisValue</span>)<br><br>//<span class="hljs-title">currentValue</span>  必需。当前元素<br>//<span class="hljs-title">index</span> 可选。当前元素的索引值。<br>//<span class="hljs-title">arr</span>   可选。当前元素所属的数组对象。<br>//<span class="hljs-title">thisValue</span> 可选。传递给函数的值一般用 "<span class="hljs-title">this</span>" 值。如果这个参数为空， "<span class="hljs-title">undefined</span>" 会传递给 "<span class="hljs-title">this</span>" 值</span><br></code></pre></td></tr></table></figure>

<h2 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h2><h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><blockquote>
<p>代理是什么？</p>
</blockquote>
<p>通过调用 <code>new Proxy()</code> ，你可以创建一个代理用来替代另一个对象（被称之为目目标对象） ，这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。</p>
<p>代理允许你拦截目标对象上的底层操作，而这本来是JS引擎的内部能力，拦截行为适用了一个能响应特定操作的函数（被称之为陷阱）；</p>
<blockquote>
<p>反射是什么？</p>
</blockquote>
<p>被<code>Reflect</code>对象所代表的反射接口，<strong>是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的</strong>。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。</p>
<blockquote>
<p>创建一个简单的代理</p>
</blockquote>
<p>使用Proxy构建可以创建一个简单的代理对象，需要传递两个参数：<strong>目标对象以及一个处理器，后者是定义一个或多个陷阱函数的对象</strong>。如果不定义陷阱函数，则依然使用目标对象的默认行为。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><h4 id="1、使用Set陷阱函数验证属性值"><a href="#1、使用Set陷阱函数验证属性值" class="headerlink" title="1、使用Set陷阱函数验证属性值"></a>1、使用Set陷阱函数验证属性值</h4><p>假如有这样一个场景，必须要求对象的属性值必须只能是数值，这就意味着该对象每个新增属性时都要被验证，并且在属性不为数值属性时就应该抛出错误。因此就需要使用<code>set</code>陷阱函数来重写<code>set</code>函数的默认行为，<code>set</code>陷阱函数接收四个参数：</p>
<ol>
<li>trapTarget：代理的目标对象；</li>
<li>key：需要写入的属性的键；</li>
<li>value：被写入属性的值；</li>
<li>receiver：操作发生的对象（通常是代理对象）</li>
</ol>
<p><code>Reflect.set()</code>是<code>set</code>陷阱函数对应的反射方法，同时也是<code>set</code>操作的默认行为，<code>Reflect.set()</code>方法与<code>set</code>陷阱函数一样，能够接受四个参数。</p>
<p>针对上述场景，示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//set陷阱函数</span><br><span class="hljs-keyword">let</span> target = &#123;<br>	<span class="hljs-attr">name</span>:<span class="hljs-string">'target'</span><br>&#125;<br><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target,&#123;<br>	<span class="hljs-keyword">set</span>(tarpTarget,key,value,receiver)&#123;<br><br>		<span class="hljs-keyword">if</span>(!tarpTarget.hasOwnProperty(key))&#123;<br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNaN</span>(value))&#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'property must be number'</span>);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(tarpTarget,key,value,receiver);<br>	&#125;<br>&#125;);<br><br>proxy.msg=<span class="hljs-string">'hello proxy'</span>; <span class="hljs-comment">//Uncaught Error: property must be number</span><br></code></pre></td></tr></table></figure>

<p>通过set陷阱函数就可以检测设置属性时属性值的类型，当属性值不是数字时，就会抛出错误。</p>
<h4 id="2-使用get陷阱函数进行对象外形验证"><a href="#2-使用get陷阱函数进行对象外形验证" class="headerlink" title="2.使用get陷阱函数进行对象外形验证"></a><strong>2.使用get陷阱函数进行对象外形验证</strong></h4><p><strong>对象外形（Object Shape）指的是对象已有的属性与方法的集合。</strong>能够使用代理很方便进行对象外形验证。由于使用属性验证只需要在读取属性时被触发，因此只需要使用<code>get陷阱函数</code>。该函数接受三个参数：</p>
<ol>
<li>trapTarget：代理的目标对象；</li>
<li>key：需要读取的属性的键；</li>
<li>receiver：操作发生的对象（通常是代理对象）；</li>
</ol>
<p>相应的<code>Reflect.get()</code>方法同样拥有这三个参数。进行对象外形验证的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//get陷阱函数</span><br><br><span class="hljs-keyword">let</span> target=&#123;<br>	<span class="hljs-attr">name</span>:<span class="hljs-string">'hello world'</span><br>&#125;<br><br><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target,&#123;<br>		<span class="hljs-keyword">get</span>(tarpTarget,key,receiver)&#123;<br>			<span class="hljs-keyword">if</span>(!(key <span class="hljs-keyword">in</span> tarpTarget))&#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'不存在该对象'</span>);<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(tarpTarget,key,receiver);<br>		&#125;<br>	&#125;);<br><span class="hljs-built_in">console</span>.log(proxy.name); <span class="hljs-comment">//hello world</span><br><span class="hljs-built_in">console</span>.log(proxy.age); <span class="hljs-comment">// Uncaught Error: 不存在该对象</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>使用<code>get陷阱函数</code>进行对象外形验证，由于<code>target</code>对象存在<code>name</code>属性，所以可以正常返回，当获取<code>age</code>属性时，由于该属性并不存在，所以会抛出错误。</p>
<h4 id="3-使用has陷阱函数隐藏属性"><a href="#3-使用has陷阱函数隐藏属性" class="headerlink" title="3.使用has陷阱函数隐藏属性"></a><strong>3.使用has陷阱函数隐藏属性</strong></h4><p><code>in</code>运算符用于判断指定对象中是否存在某个属性，如果对象的属性名与指定的字符串或符号值相匹配，那么<code>in</code>运算符就会返回<code>true</code>。无论该属性是对象自身的属性还是其原型的属性。</p>
<p><code>has陷阱函数</code>会在使用<code>in</code>运算符的情况下被调用，控制in运算符返回不同的结果，<code>has陷阱函数</code>会传入两个参数：</p>
<ol>
<li>trapTarget：代理的目标对象；</li>
<li>key：属性键；</li>
</ol>
<p><code>Reflect.has()</code>方法接收相同的参数，并向<code>in</code>运算符返回默认的响应结果，用于返回默认响应结果。</p>
<p>例如想要隐藏value属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//has陷阱函数</span><br><span class="hljs-keyword">let</span> target = &#123;<br>	<span class="hljs-attr">value</span>:<span class="hljs-string">'hello world'</span><br>&#125;<br><br><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target,&#123;<br>	has(tarpTarget,key)&#123;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">Object</span>.is(key,<span class="hljs-string">'value'</span>))&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>		<span class="hljs-built_in">Reflect</span>.has(tarpTarget,key);<br>	&#125;<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value'</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">//false</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>使用<code>has陷阱函数</code>，能够控制<code>in</code>运算符的结果，<code>value</code>属性在<code>target对象</code>中存在，通过代理的<code>has陷阱函数</code>使得在检查<code>value</code>属性时返回<code>false</code>，达到隐藏属性的效果。</p>
<h4 id="4-使用deleteProperty陷阱函数避免属性被删除"><a href="#4-使用deleteProperty陷阱函数避免属性被删除" class="headerlink" title="4.使用deleteProperty陷阱函数避免属性被删除"></a><strong>4.使用deleteProperty陷阱函数避免属性被删除</strong></h4><p><code>deleteProperty</code> 陷阱函数会在使用<code>delete</code> 运算符删除对象属性时被调用，该方法接收两个参数：</p>
<ol>
<li>trapTarget：代理的目标对象；</li>
<li>key：需要删除的键；</li>
</ol>
<p><code>Reflect.deleteProperty()</code> 方法也接受这两个参数，并提供了 <code>deleteProperty</code> 陷阱函数的默认实现。你可以结合 <code>Reflect.deleteProperty()</code>方法以及 <code>deleteProperty</code> 陷阱函数，来修改 <code>delete</code> 运算符的行为。例如，能确保 value 属性不被删除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<br>	<span class="hljs-attr">name</span>: <span class="hljs-string">"target"</span>,<br>	<span class="hljs-attr">value</span>: <span class="hljs-number">42</span><br>&#125;;<br><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>	deleteProperty(trapTarget, key) &#123;<br>		<span class="hljs-keyword">if</span> (key === <span class="hljs-string">"value"</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(trapTarget, key);<br>		&#125;<br>	&#125;<br>&#125;);<br><span class="hljs-comment">// 尝试删除 proxy.value</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"value"</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">delete</span> proxy.value;<br><span class="hljs-built_in">console</span>.log(result1); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h1 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h1><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>
<h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>导致回流的一些操作</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p>主要有下面几个API</p>
<blockquote>
<p>盒子操作相关</p>
</blockquote>
<ul>
<li><code>elem.offsetLeft</code>, <code>elem.offsetTop</code>, <code>elem.offsetWidth</code>, <code>elem.offsetHeight</code>, <code>elem.offsetParent</code></li>
<li><code>elem.clientLeft</code>, <code>elem.clientTop</code>, <code>elem.clientWidth</code>, <code>elem.clientHeight</code></li>
<li><code>elem.getClientRects()</code>, <code>elem.getBoundingClientRect()</code></li>
</ul>
<blockquote>
<p>滚动相关</p>
</blockquote>
<ul>
<li><code>elem.scrollBy()</code>, <code>elem.scrollTo()</code></li>
<li><code>elem.scrollIntoView()</code>, <code>elem.scrollIntoViewIfNeeded()</code></li>
<li><code>elem.scrollWidth</code>, <code>elem.scrollHeight</code></li>
<li><code>elem.scrollLeft</code>, <code>elem.scrollTop</code></li>
</ul>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>当我们操作的节点上的元素并不导致元素位置发生变化时，比如<code>color</code>,<code>background-color</code>,<code>visibility(注意虽然节点隐藏了，但是元素还在，并且位置也不会发生变化)</code></p>
<p>浏览器会将新的样式赋值给这些节点，我们称这个过程为重绘</p>
<h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ul>
<li>避免使用 <code>table</code> 布局。</li>
<li>尽可能在 <code>DOM</code> 树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
</ul>
<p>-避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM</code>操作，最后再把它添加到文档中。</p>
<ul>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="CSS-几种单位"><a href="#CSS-几种单位" class="headerlink" title="CSS 几种单位"></a>CSS 几种单位</h2><h3 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h3><p>一般来说，常用<code>px</code></p>
<h3 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h3><table>
<thead>
<tr>
<th><code>em</code></th>
<th>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</th>
</tr>
</thead>
<tbody><tr>
<td><code>ex</code></td>
<td>字符“x”的高度</td>
</tr>
<tr>
<td><code>ch</code></td>
<td>数字“0”的宽度</td>
</tr>
<tr>
<td><code>rem</code></td>
<td>根元素 <code>&lt;html&gt;</code> 的字体大小</td>
</tr>
<tr>
<td><code>lh</code></td>
<td>元素的line-height</td>
</tr>
<tr>
<td><code>vw</code></td>
<td>视窗宽度的1%</td>
</tr>
<tr>
<td><code>vh</code></td>
<td>视窗高度的1%</td>
</tr>
<tr>
<td><code>vmin</code></td>
<td>视窗较小尺寸的1%</td>
</tr>
<tr>
<td><code>vmax</code></td>
<td>视图大尺寸的1%</td>
</tr>
</tbody></table>
<h2 id="CSS-处理字符串"><a href="#CSS-处理字符串" class="headerlink" title="CSS 处理字符串"></a>CSS 处理字符串</h2><h3 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h3><p><code>clip</code></p>
<p><strong>此为默认值。</strong>这个关键字的意思是”在内容区域的极限处截断文本”，因此在字符的中间可能会发生截断。如果你的目标浏览器支持 <code>text-overflow: &#39;&#39;</code>，为了能在两个字符过渡处截断，你可以使用一个空字符串值 (<code>&#39;&#39;</code>) 作为 <code>text-overflow</code> 属性的值。</p>
<p><code>ellipsis</code></p>
<p>这个关键字的意思是“用一个省略号 (<code>&#39;…&#39;</code>, <code>U+2026 HORIZONTAL ELLIPSIS</code>)来表示被截断的文本”。这个省略号被添加在内容区域中，因此会减少显示的文本。如果空间太小到连省略号都容纳不下，那么这个省略号也会被截断。</p>
<p><code>&lt;string&gt;</code></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/string" target="_blank" rel="noopener"><code>&lt;string&gt;</code></a>用来表示被截断的文本。字符串内容将被添加在内容区域中，所以会减少显示出的文本。如果空间太小到连省略号都容纳不下，那么这个字符串也会被截断。</p>
<h3 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h3><p><code>normal</code></p>
<p>行只能在正常的单词断点处中断。（例如两个单词之间的空格）。</p>
<p><code>break-word</code></p>
<p>表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。</p>
<h3 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h3><p><code>capitalize</code></p>
<p>这个关键字强制每个单词的首字母转换为大写。其他的字符保留不变（它们写在元素里的文本保留原始大小写）。字母是Unicode字符集或者数字里定义的字符 ；因此单词开头的任何标点符号或者特殊符号将会被忽略。</p>
<p>Authors should not expect <code>capitalize</code> to follow language-specific titlecasing conventions (such as skipping articles in English).</p>
<p><code>uppercase</code></p>
<p>这个关键字强制所有字符被转换为大写。</p>
<p><code>lowercase</code></p>
<p>这个关键字强制所有字符被转换为小写。</p>
<p><code>none</code></p>
<p>这个关键字阻止所有字符的大小写被转换。</p>
<p><code>full-width</code></p>
<p>这个关键字强制字符 — 主要是表意字符和拉丁文字 — 书写进一个方形里，并允许它们按照一般的东亚文字（比如中文或日文）对齐。</p>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>比较简单，可以用<code>flex</code>，可以用<code>text-align</code></p>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="单行内联-inline-元素垂直居中"><a href="#单行内联-inline-元素垂直居中" class="headerlink" title="单行内联(inline-)元素垂直居中"></a>单行内联(<code>inline-</code>)元素垂直居中</h4><p>通过设置内联元素的高度(<code>height</code>)和行高(<code>line-height</code>)相等，从而使元素垂直居中。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#v-box</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">120px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="利用flex布局（flex）"><a href="#利用flex布局（flex）" class="headerlink" title="利用flex布局（flex）"></a>利用flex布局（<code>flex</code>）</h4><p>利用flex布局实现垂直居中，其中 <code>flex-direction: column</code> 定义主轴方向为纵向。因为flex布局是 <code>CSS3</code> 中定义，在较老的浏览器存在兼容性问题。</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center-flex</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="BFC-IFC-Flex"><a href="#BFC-IFC-Flex" class="headerlink" title="BFC IFC Flex"></a>BFC IFC Flex</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><code>Block Formatting Context</code>，块级格式化上下文，一个独立的块级渲染区域，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p>
<h4 id="BFC的应用"><a href="#BFC的应用" class="headerlink" title="BFC的应用"></a>BFC的应用</h4><ul>
<li>防止<code>margin</code>发生重叠</li>
<li>防止发生因浮动导致的高度塌陷</li>
</ul>
<h4 id="怎么生成-BFC"><a href="#怎么生成-BFC" class="headerlink" title="怎么生成 BFC"></a>怎么生成 BFC</h4><ul>
<li><code>float</code>的值不为<code>none</code>；</li>
<li><code>overflow</code>的值不为<code>visible</code>；</li>
<li><code>display</code>的值为<code>inline-block</code> <code>table-cell</code> <code>table-caption</code>；</li>
<li><code>position</code>的值为<code>absolute</code>或<code>fixed</code>；</li>
</ul>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p><code>IFC(Inline Formatting Contexts)</code>直译为”行内格式化上下文”，<code>IFC</code>的<code>line box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)</p>
<h4 id="IFC有的特性"><a href="#IFC有的特性" class="headerlink" title="IFC有的特性"></a>IFC有的特性</h4><ol>
<li><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个<code>IFC</code>，但是会因为<code>float</code>元素而扰乱。<code>float</code>元素会位于<code>IFC</code>与与<code>line box</code>之间，使得<code>line box</code>宽度缩短。</li>
<li><code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如<code>p</code>中插入<code>div</code>）会产生两个匿名块与<code>div</code>分隔开，即产生两个<code>IFC</code>，每个<code>IFC</code>对外表现为块级元素，与<code>div</code>垂直排列。</li>
</ol>
<h4 id="IFC的应用"><a href="#IFC的应用" class="headerlink" title="IFC的应用"></a>IFC的应用</h4><ol>
<li>水平居中：当一个块要在环境中水平居中时，设置其为<code>inline-block</code>则会在外层产生<code>IFC</code>，通过<code>text-align</code>则可以使其水平居中。</li>
<li>垂直居中：创建一个<code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其<code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中。</li>
</ol>
<h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">flex-direction</span> <span class="hljs-comment">//方向</span><br><span class="hljs-attribute">flex-wrap</span> <span class="hljs-comment">//换行</span><br><span class="hljs-attribute">flex-flow</span> <span class="hljs-comment">// 前两个属性的集合</span><br><span class="hljs-attribute">justify-content</span>  <span class="hljs-comment">//主轴对齐方式</span><br><span class="hljs-attribute">align-items</span> <span class="hljs-comment">//交叉轴对齐方式</span><br><span class="hljs-attribute">align-content</span> <span class="hljs-comment">//多轴线对齐方式</span><br></code></pre></td></tr></table></figure>

<h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">order</span> <span class="hljs-comment">//顺序</span><br><span class="hljs-attribute">flex-grow</span> <span class="hljs-comment">//放大比例，0为不放大</span><br><span class="hljs-attribute">flex-shrink</span> <span class="hljs-comment">//缩小比例，默认1, 0为不缩小</span><br><span class="hljs-attribute">flex-basis</span> <span class="hljs-comment">//分配前所占空间</span><br><span class="hljs-attribute">flex</span> <span class="hljs-comment">// 上面3个属性的集合</span><br><span class="hljs-attribute">align-self</span>  <span class="hljs-comment">//这个元素的对齐方式，覆盖容器的align-items</span><br></code></pre></td></tr></table></figure>

<h4 id="flex-1-？？？"><a href="#flex-1-？？？" class="headerlink" title="flex:1 ？？？"></a><code>flex:1</code> ？？？</h4><p>可以使用一个，两个或三个值来指定 <code>flex</code>属性。</p>
<p><strong>单值语法</strong>: 值必须为以下其中之一:</p>
<ul>
<li>一个无单位<strong>数</strong>: 它会被当作<code>flex:&lt;number&gt; 1 0;</code> <code>&lt;flex-shrink&gt;</code>的值被假定为1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为<code>0</code>。</li>
<li>一个有效的**宽度(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width" target="_blank" rel="noopener"><code>width</code></a>)**值: 它会被当作 <code>&lt;flex-basis&gt;的值。</code></li>
<li>关键字<code>none</code>，<code>auto</code>或<code>initial</code>.</li>
</ul>
<p><strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</p>
<ul>
<li>一个无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>
<li>一个有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>
</ul>
<p><strong>三值语法:</strong></p>
<ul>
<li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li>
<li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>
<li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>
</ul>
<h4 id="flex取值"><a href="#flex取值" class="headerlink" title="flex取值"></a>flex取值</h4><ul>
<li><p><code>initial</code></p>
<p>元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为”<code>flex: 0 1 auto</code>“。</p>
</li>
<li><p><code>auto</code></p>
<p>元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 “<code>flex: 1 1 auto</code>“.</p>
</li>
<li><p><code>none</code></p>
<p>元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”<code>flex: 0 0 auto</code>“。</p>
</li>
</ul>
<h2 id="如何做一个三栏布局"><a href="#如何做一个三栏布局" class="headerlink" title="如何做一个三栏布局"></a>如何做一个三栏布局</h2><p>1、Flex</p>
<p>2、<code>inline-block</code></p>
<p>3、<code>float</code> 实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrap"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"middle"</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css"><br>    <span class="hljs-selector-class">.wrap</span> &#123;<span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>; <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;&#125;  &lt;!<span class="hljs-selector-tag">--</span> 生成<span class="hljs-selector-tag">BFC</span>，计算高度时考虑浮动的元素 <span class="hljs-selector-tag">--</span>&gt;<br><br>    <span class="hljs-selector-class">.left</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>; <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">background</span>: coral;&#125;<br>    <span class="hljs-selector-class">.right</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>; <span class="hljs-attribute">height</span>:  <span class="hljs-number">200px</span>; <span class="hljs-attribute">float</span>: right; <span class="hljs-attribute">background</span>: lightblue;&#125;<br>    <span class="hljs-selector-class">.middle</span> &#123;<span class="hljs-attribute">margin-left</span>: <span class="hljs-number">220px</span>; <span class="hljs-attribute">background</span>: lightpink; <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">140px</span>;&#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h1><h2 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a><code>meta</code> 标签</h2><h4 id="charset"><a href="#charset" class="headerlink" title="charset"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-charset" target="_blank" rel="noopener"><code>charset</code></a></h4><p>这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与 ASCII 大小写无关（ASCII case-insensitive）的”<code>utf-8</code>“。</p>
<h4 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-http-equiv" target="_blank" rel="noopener"><strong><code>http-equiv</code></strong></a></h4><p>属性定义了一个编译指示指令。这个属性叫做 <code>**http-equiv**(alent)</code> 是因为所有允许的值都是特定 HTTP 头部的名称，如下：</p>
<ul>
<li><p><code>content-security-policy</code><br>它允许页面作者定义当前页的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">内容策略</a>。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</p>
</li>
<li><p><code>content-type</code><br>如果使用这个属性，其值必须是”<code>text/html; charset=utf-8</code>“。注意：该属性只能用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME type</a> 为 <code>text/html</code> 的文档，不能用于 MIME 类型为 XML 的文档。</p>
</li>
<li><p><code>default-style</code></p>
<p>设置默认 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS 样式表</a>组的名称。</p>
</li>
<li><p><code>x-ua-compatible</code><br>如果指定，则 <code>content</code> 属性必须具有值 “<code>IE=edge</code>“。用户代理必须忽略此指示。</p>
</li>
<li><p><code>refresh</code></p>
<p>这个属性指定：</p>
<ul>
<li>如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content" target="_blank" rel="noopener"><code>content</code></a> 只包含一个正整数，则为重新载入页面的时间间隔 (秒)；</li>
<li>如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content" target="_blank" rel="noopener"><code>content</code></a> 包含一个正整数，并且后面跟着字符串 ‘<code>;url=</code>‘ 和一个合法的 URL，则是重定向到指定链接的时间间隔 (秒)</li>
</ul>
</li>
</ul>
<h4 id="meta-做-SEO"><a href="#meta-做-SEO" class="headerlink" title="meta 做 SEO"></a>meta 做 SEO</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title of the page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”description”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”Everything</span> <span class="hljs-attr">you</span> <span class="hljs-attr">need</span> <span class="hljs-attr">to</span> <span class="hljs-attr">know</span> <span class="hljs-attr">about</span> <span class="hljs-attr">meta</span> <span class="hljs-attr">tags</span> <span class="hljs-attr">for</span> <span class="hljs-attr">search</span> <span class="hljs-attr">engine</span> <span class="hljs-attr">optimization</span>”&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”keywords”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”meta</span> <span class="hljs-attr">tags</span>,<span class="hljs-attr">search</span> <span class="hljs-attr">engine</span> <span class="hljs-attr">optimization</span>” &gt;</span><br></code></pre></td></tr></table></figure>



<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="从输入url到呈现网页"><a href="#从输入url到呈现网页" class="headerlink" title="从输入url到呈现网页"></a>从输入url到呈现网页</h2><p>（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<p>（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>
<p>（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p>（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>
<p>（9）最后一步是 TCP 断开连接的四次挥手过程。</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0/1.1/2.0/3.0"></a>HTTP 1.0/1.1/2.0/3.0</h3><h4 id="HTTP-1-0-1-1"><a href="#HTTP-1-0-1-1" class="headerlink" title="HTTP 1.0/1.1"></a>HTTP 1.0/1.1</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。</p>
<p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p>
<p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。</p>
<h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> HTTP/1.1<br><span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<br><span class="hljs-attribute">Accept</span>: */*<br></code></pre></td></tr></table></figure>

<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p>
<p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p>
<p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。 POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应 中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象，表达的是一种语义上的区别。</p>
<h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><p>HTTP 响应报文的格式如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OK<br>Content-Type: text/plain<br>Content-Length: <span class="hljs-number">137582</span><br>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT<br>Last-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMT<br>Server: Apache <span class="hljs-number">0.84</span><br><br>&lt;html&gt;<br>  &lt;body&gt;Hello World&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p>
<p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p>
<p>实体部分是报文的主要部分，它包含了所请求的对象。</p>
<h5 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h5><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理 301-永久移动、302-临时移动、304-所请求的资源未修改、 400-客户端请求的语法错误、404-请求的资源不存在 500-服务器内部错误。</p>
<p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p>
<h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设 置，区别在于请求首部和响应首部。</p>
<p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p>
<p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p>
<p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p>
<p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p>
<h5 id="常见的-Content-Type"><a href="#常见的-Content-Type" class="headerlink" title="常见的 Content-Type"></a>常见的 Content-Type</h5><ul>
<li><p>text/html ： HTML格式</p>
</li>
<li><p>text/plain ：纯文本格式</p>
</li>
<li><p>text/xml ： XML格式</p>
</li>
<li><p>image/gif ：gif图片格式</p>
</li>
<li><p>image/jpeg ：jpg图片格式</p>
</li>
<li><p>image/png：png图片格式</p>
</li>
<li><p>application/xml： XML数据格式</p>
</li>
<li><p>application/json： JSON数据格式</p>
</li>
<li><p>application/octet-stream ： 二进制流数据（如常见的文件下载）</p>
</li>
<li><p>application/x-www-form-urlencoded ：form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</p>
</li>
<li><p>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</p>
</li>
</ul>
<h4 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h4><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他 资源请求完成后才能发起请求。</p>
<p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的 原因。</p>
<h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明 可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p>
<p>HTTP/2 主要有以下新的特性：</p>
<h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><strong>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</strong></p>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p>
<h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p>
<p>详细的资料可以参考： <a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">《HTTP 协议入门》</a> <a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank" rel="noopener">《HTTP/2 服务器推送（Server Push）教程》</a></p>
<h4 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h4><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都 会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p>
<h4 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h4><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p>
<p>详细资料可以参考： <a href="https://www.zhihu.com/question/302412059" target="_blank" rel="noopener">《如何看待 HTTP/3 ？》</a></p>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h4><ol>
<li>HTTP 报文使用明文方式发送，可能被第三方窃听。</li>
<li>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</li>
<li>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</li>
</ol>
<h4 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立 刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p>
<h4 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h4><ol>
<li>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p>
<p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。</p>
<p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p>
<p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p>
<h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分 布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号 端口。</p>
<h4 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h4><p>域名的层级结构可以如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">主机名.次级域名.顶级域名.根域名<br><br># 即<br><br><span class="hljs-selector-tag">host</span><span class="hljs-selector-class">.sld</span><span class="hljs-selector-class">.tld</span><span class="hljs-selector-class">.root</span><br></code></pre></td></tr></table></figure>

<p>根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</p>
<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</p>
<ol>
<li>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li>
<li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li>
<li>从”次级域名服务器”查出”主机名”的 IP 地址。</li>
</ol>
<p>比如我们如果想要查询 <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a> 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务 器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名 服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服 务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h4 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h4><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<p>（Name，Value，Type，TTL）</p>
<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p>
<ol>
<li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ol>
<h4 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h4><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</p>
<p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</p>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本 地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</p>
<h4 id="DNS-实现负载平衡"><a href="#DNS-实现负载平衡" class="headerlink" title="DNS 实现负载平衡"></a>DNS 实现负载平衡</h4><p>DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在 每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不 同的服务器上，这样来实现负载均衡。</p>
<h2 id="TCP握手与挥手"><a href="#TCP握手与挥手" class="headerlink" title="TCP握手与挥手"></a>TCP握手与挥手</h2><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>第一次握手，客户端向服务器发送一个 <strong>SYN</strong> 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的 随机数。它代表的是客户端数据的初始序号。</p>
<p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接<strong>分配 TCP 缓存和变量</strong>，然后向 客户端发送 <strong>SYN ACK</strong> 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认， 同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加 一。</p>
<p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接<strong>分配缓存和变量</strong>，同时向服务器端发送一个对服务 器端的报文段的确认。<strong>第三次握手可以在报文段中携带数据</strong>。</p>
<p>在我看来，TCP 三次握手的建立连接的过程就是相互确认<strong>初始序号</strong>的过程，告诉对方，什么样<strong>序号</strong>的报文段能够被正确接收。 第三次握手的作用是<strong>客户端对服务器端的初始序号的确认</strong>。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<h3 id="挥手"><a href="#挥手" class="headerlink" title="挥手"></a>挥手</h3><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p>
<p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 <strong>FIN</strong> 报文段，申请断开客户端到服务器端的 连接。发送后<strong>客户端进入 FIN_WAIT_1</strong> 状态。</p>
<p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的 请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 <strong>CLOSE_WAIT</strong> 状态。客户端收到确认后，进入 <strong>FIN_WAIT_2</strong> 状态。</p>
<p>第三次挥手，服务器端发送完所有数据后，向客户端发送 <strong>FIN</strong> 报文段，申请断开服务器端到客户端的连接。发送后进入 <strong>LAST_ACK</strong> 状态。</p>
<p>第四次挥手，客户端接收到 <strong>FIN</strong> 请求后，向服务器端发送一个确认应答，并进入 <strong>TIME_WAIT</strong> 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 <strong>CLOSED</strong> 的状态。如果收到 服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 <strong>CLOSED</strong> 状态，这样全双工的连接就被 释放了。</p>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了<strong>防止发送给服务器的确认报文段丢失或者出错</strong>，从而导致服务器端不能正常关闭。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><strong>Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示</strong>，如：<code>Expires:Thu, 31 Dec 2037 23:55:55 GMT</code> ，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。</p>
<p>例如，一个文件的Expires值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。</p>
<p>所以，<strong>Expires是优化中最理想的情况，因为它根本不会产生请求</strong>，所以后端也就无需考虑查询快慢。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header。</p>
<p>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p>
<p>3、浏览器再请求这个资源时，<strong>先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较</strong>，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</p>
<p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p><strong>Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</strong>，如： <code>Cache-Control:max-age=315360000</code> 。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header。</p>
<p>2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
<p>3、浏览器再请求这个资源时，<strong>先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期</strong>，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</p>
<p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，<strong>Cache-Control Header在重新加载的时候会被更新</strong>；</p>
<p>此外，还可以为 Cache-Control 指定 <code>public</code> 或 <code>private</code> 标记。<strong>如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源</strong>。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。<strong>对于 public，则允许所有服务器缓存该资源</strong>。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），<strong>Cache-Control 默认设为 public 是合理的</strong>。</p>
<p>这两个header可以只启用一个，也可以同时启用，<strong>当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires</strong></p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，<strong>就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</strong>。</p>
<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified If-Modified-Since"></a>Last-Modified If-Modified-Since</h4><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，<strong>在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</strong></p>
<p>2、浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上If-Modified-Since的header</strong>，这个header的值就是上一次请求时返回的Last-Modified的值。</p>
<p>3、服务器再次收到资源请求时，<strong>根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化</strong>，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。<strong>当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header</strong>，因为既然资源没有变化，那么Last-Modified也就不会改变。</p>
<p>4、浏览器收到304的响应后，就会从缓存中加载资源。</p>
<p>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，<strong>Last-Modified Header在重新加载的时候会被更新</strong>，下次请求时，<strong>If-Modified-Since会启用上次返回的Last-Modified值</strong>。</p>
<h4 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h4><p>1、浏览器第一次跟服务器请求一个资源，<strong>服务器在返回这个资源的同时，在response的header加上ETag的header</strong>，这个header是服务器根据当前请求的资源生成的一个唯一标识，<strong>这个唯一标识是一个字符串，只要资源有变化这个串就不同</strong>，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</p>
<p>2、浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上If-None-Match的header</strong>，这个header的值就是上一次请求时返回的ETag的值：</p>
<p>3、服务器再次收到资源请求时，<strong>根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag</strong>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，<strong>由于ETag重新生成过，response header中还会把这个ETag返回</strong>，即使这个ETag跟之前的没有变化：</p>
<p>4、浏览器收到304的响应后，就会从缓存中加载资源。</p>
<p>Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。<strong>但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改</strong>，从而在实际操作中实用程度也更高。</p>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，<strong>所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器</strong>，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】。</p>
<h3 id="用户操作导致的缓存失效"><a href="#用户操作导致的缓存失效" class="headerlink" title="用户操作导致的缓存失效"></a>用户操作导致的缓存失效</h3><p>当用户在按<code>F5</code>进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；<br>而当用户使用<code>Ctrl+F5</code>进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。<br>CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p>
<h3 id="CDN缓存策略"><a href="#CDN缓存策略" class="headerlink" title="CDN缓存策略"></a><strong>CDN缓存策略</strong></h3><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
<p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<p>CDN缓存时间会对“回源率”产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
<h3 id="CDN缓存刷新"><a href="#CDN缓存刷新" class="headerlink" title="CDN缓存刷新"></a><strong>CDN缓存刷新</strong></h3><p>CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<h1 id="工程与应用相关"><a href="#工程与应用相关" class="headerlink" title="工程与应用相关"></a>工程与应用相关</h1><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p>
<p>先获取所有图片的 <code>dom</code>，通过 <code>document.body.clientHeight</code> 获取可视区高度，再使用 <code>element.getBoundingClientRect()</code> API 直接得到元素相对浏览的 top 值， 遍历每个图片判断当前图片是否到了可视区范围内。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> viewHeight = <span class="hljs-built_in">document</span>.body.clientHeight <span class="hljs-comment">//获取可视区高度</span><br>  <span class="hljs-keyword">let</span> imgs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img[data-src]'</span>)<br>  imgs.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item.dataset.src === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span><br>    <span class="hljs-keyword">let</span> rect = item.getBoundingClientRect()<br>    <span class="hljs-keyword">if</span> (rect.bottom &gt;= <span class="hljs-number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;<br>      item.src = item.dataset.src<br>      item.removeAttribute(<span class="hljs-string">'data-src'</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后给 window 绑定 <code>onscroll</code> 事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, lazyload)<br></code></pre></td></tr></table></figure>

<p><strong>注意运用节流。</strong></p>
<p><code>IntersectionObserver</code> 是一个新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(callback, option)<br><br><span class="hljs-comment">// 开始观察</span><br>io.observe(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'example'</span>))<br><br><span class="hljs-comment">// 停止观察</span><br>io.unobserve(element)<br><br><span class="hljs-comment">// 关闭观察器</span><br>io.disconnect()<br></code></pre></td></tr></table></figure>

<h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><p><code>IntersectionObserver</code> 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。</p>
<p>目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(entries)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>callback 函数的参数<code>（entries）</code>是一个数组，每个成员都是一个 <code>IntersectionObserverEntry</code> 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code> 数组就会有两个成员。</p>
<ul>
<li>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>
<li>target：被观察的目标元素，是一个 DOM 节点对象</li>
<li>isIntersecting: 目标是否可见</li>
<li>rootBounds：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null</li>
<li>boundingClientRect：目标元素的矩形区域的信息</li>
<li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li>
<li>intersectionRatio：目标元素的可见比例，即 <code>intersectionRect</code> 占 <code>boundingClientRect</code> 的比例，完全可见时为 1，完全不可见时小于等于 0</li>
</ul>
<p>下面我们用 <code>IntersectionObserver</code> 实现图片懒加载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> imgs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img[data-src]'</span>)<br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'0px'</span>,<br>  <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>,<br>&#125;<br><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">entries, self</span>) =&gt;</span> &#123;<br>  entries.forEach(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.isIntersecting) &#123;<br>      <span class="hljs-keyword">let</span> img = entry.target<br>      <span class="hljs-keyword">let</span> src = img.dataset.src<br>      <span class="hljs-keyword">if</span> (src) &#123;<br>        img.src = src<br>        img.removeAttribute(<span class="hljs-string">'data-src'</span>)<br>      &#125;<br>      <span class="hljs-comment">// 解除观察</span><br>      self.unobserve(entry.target)<br>    &#125;<br>  &#125;)<br>&#125;, config)<br><br>imgs.forEach(<span class="hljs-function">(<span class="hljs-params">image</span>) =&gt;</span> &#123;<br>  observer.observe(image)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><h3 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h3><p>hash 就是指 url 后的 # 号以及后面的字符</p>
<p>由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 hashchange 事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.location.hash = <span class="hljs-string">'hash字符串'</span>; <span class="hljs-comment">// 用于设置 hash 值</span><br><br><span class="hljs-keyword">let</span> hash = <span class="hljs-built_in">window</span>.location.hash; <span class="hljs-comment">// 获取当前 hash 值</span><br><br><span class="hljs-comment">// 监听hash变化，点击浏览器的前进后退会触发</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123; <br>    <span class="hljs-keyword">let</span> newURL = event.newURL; <span class="hljs-comment">// hash 改变后的新 url</span><br>    <span class="hljs-keyword">let</span> oldURL = event.oldURL; <span class="hljs-comment">// hash 改变前的旧 url</span><br>&#125;,<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure>

<h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><h4 id="history-api"><a href="#history-api" class="headerlink" title="history api"></a>history api</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">history</span>.pushState<span class="hljs-params">()</span>;         <span class="hljs-string">//</span> 添加新的状态到历史状态栈<br><span class="hljs-keyword">history</span>.replaceState<span class="hljs-params">()</span>;      <span class="hljs-string">//</span> 用新的状态代替当前状态<br><span class="hljs-keyword">history</span>.state                <span class="hljs-string">//</span> 返回当前状态对象<br></code></pre></td></tr></table></figure>

<p>history.pushState() 和 history.replaceState() 的区别在于：</p>
<ul>
<li>history.pushState() 在保留现有历史记录的同时，将 url 加入到历史记录中。</li>
<li>history.replaceState() 会将历史记录中的当前页面历史替换为 url。</li>
</ul>
<p>由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面，所以在 HTML5 中的 histroy 具备了实现前端路由的能力。</p>
<h4 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a><code>window.location</code></h4><h5 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location/href" target="_blank" rel="noopener"><code>Location.href</code></a></p>
<p>包含整个URL的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/protocol" target="_blank" rel="noopener"><code>Location.protocol</code> (en-US)</a></p>
<p>包含URL对应协议的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a>，最后有一个”:”。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location/host" target="_blank" rel="noopener"><code>Location.host</code></a></p>
<p>包含了域名的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a>，可能在该串最后带有一个”:”并跟上URL的端口号。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location/hostname" target="_blank" rel="noopener"><code>Location.hostname</code></a></p>
<p>包含URL域名的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a>。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/port" target="_blank" rel="noopener"><code>Location.port</code> (en-US)</a></p>
<p>包含端口号的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a>。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/pathname" target="_blank" rel="noopener"><code>Location.pathname</code> (en-US)</a></p>
<p>包含URL中路径部分的一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" target="_blank" rel="noopener"><code>DOMString</code></a>，开头有一个“<code>/&quot;。</code></p>
<h2 id="前端安全问题以及解决方案"><a href="#前端安全问题以及解决方案" class="headerlink" title="前端安全问题以及解决方案"></a>前端安全问题以及解决方案</h2><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li></li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<h4 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h4><p>DOM 型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL。</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<h4 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h4><p>必要的输入过滤</p>
<p>改成纯前端渲染，把代码和数据分隔开。</p>
<p>对 HTML 做充分转义。（在输出时）</p>
<p>使用CSP</p>
<h5 id="预防DOM型"><a href="#预防DOM型" class="headerlink" title="预防DOM型"></a>预防DOM型</h5><p>在涉及以下字符串拼接时注意：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"UNTRUSTED"</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">"UNTRUSTED"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"data:image/png,"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"UNTRUSTED"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br><span class="hljs-comment">// setTimeout()/setInterval() 中调用恶意代码</span><br>setTimeout(<span class="hljs-string">"UNTRUSTED"</span>)<br>setInterval(<span class="hljs-string">"UNTRUSTED"</span>)<br><br><span class="hljs-comment">// location 调用恶意代码</span><br>location.href = <span class="hljs-string">'UNTRUSTED'</span><br><br><span class="hljs-comment">// eval() 中调用恶意代码</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">"UNTRUSTED"</span>)<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在使用时避免在字符串中拼接不可信数据。</p>
<h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><h4 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://bank.example/withdraw?amount=10000&amp;for=hacker"</span> &gt;</span><br></code></pre></td></tr></table></figure>

<p>通过一个HTTP请求</p>
<h4 id="POST型"><a href="#POST型" class="headerlink" title="POST型"></a>POST型</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"http://bank.example/withdraw"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xiaoming"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"amount"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"for"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hacker"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].submit(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过提交一个自动提交的表单</p>
<h4 id="链接型"><a href="#链接型" class="headerlink" title="链接型"></a>链接型</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker"</span> <span class="hljs-attr">taget</span>=<span class="hljs-string">"_blank"</span>&gt;</span><br>重磅消息！！<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>用户点击链接触发</p>
<h4 id="防范方法-1"><a href="#防范方法-1" class="headerlink" title="防范方法"></a>防范方法</h4><h5 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h5><p>使用Referer Header确定来源域名</p>
<p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>
<p>当Origin和Referer头文件不存在时该怎么办？如果Origin和Referer都不存在，建议直接进行阻止，特别是如果您没有使用随机CSRF Token（参考下方）作为第二次检查。</p>
<p>通过Header的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。</p>
<p>我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御CSRF攻击了吗？</p>
<p>且慢！当一个请求是页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击。所以在判断的时候需要过滤掉页面请求情况。</p>
<p>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>
<h5 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h5><p>CSRF Token机制是目前比较主流的的防御手段，其核心思路是在需要验证的请求中添加一个无法预测，无法使用浏览器策略直接提交的字段。CSRF Token可以是POST请求的一个参数、或者是一个自定义的HTTP Header，Token可以存放于<code>&lt;mata&gt;</code>标签中、JS变量中、Cookie中、浏览器Local Storage中或者DOM的任何位置，Token可以是同步令牌、加密令牌或者HMAC Token。</p>
<p>不同的生成、存储及使用方式，所带来的的安全性也是存在区别的，一般推荐使用HMAC Token、存储于DOM中，并在Ajax请求中添加自定义Header传输Token。使用CSRF Token的优点在于识别准确，后续新开发接口只需按照规则开发便可避免CSRF漏洞。缺点在于推CSRF Token机制需要前端和客户端开发付出大量时间进行调整，且一旦CSRF Token机制运转，旧版本APP可能无法使用。</p>
<h5 id="双重-token"><a href="#双重-token" class="headerlink" title="双重 token"></a>双重 token</h5><h5 id="Samesite-cookie"><a href="#Samesite-cookie" class="headerlink" title="Samesite cookie"></a>Samesite cookie</h5><p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。</p>
<p>它可以设置三个值。</p>
<blockquote>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
</blockquote>
<p><strong>Strict</strong></p>
<p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set-Cookie: CookieName=CookieValue; SameSite=Strict;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<p><strong>Lax</strong></p>
<p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markup">Set-Cookie: CookieName&#x3D;CookieValue; SameSite&#x3D;Lax;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>
<table>
<thead>
<tr>
<th align="left">请求类型</th>
<th align="center">示例</th>
<th align="right">正常情况</th>
<th align="left">Lax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">链接</td>
<td align="center"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">预加载</td>
<td align="center"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">GET 表单</td>
<td align="center"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">POST 表单</td>
<td align="center"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">iframe</td>
<td align="center"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">AJAX</td>
<td align="center"><code>$.get(&quot;...&quot;)</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">Image</td>
<td align="center"><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
</tbody></table>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ol>
<li>访问者被恶意页面吸引。怎样吸引的不重要。</li>
<li>页面上有一个看起来无害的链接（例如：“变得富有”或者“点我，超好玩！”）。</li>
<li>恶意页面在该链接上方放置了一个透明的 <code>&lt;iframe&gt;</code>，其 <code>src</code> 来自于 <a href="http://facebook.com/" target="_blank" rel="noopener">facebook.com</a>，这使得“点赞”按钮恰好位于该链接上面。这通常是通过 <code>z-index</code> 实现的。</li>
<li>用户尝试点击该链接时，实际上点击的是“点赞”按钮。</li>
</ol>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p><code>samesite</code> cookie 特性可以阻止点击劫持攻击。</p>
<p>具有 <code>samesite</code> 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。更多细节请见 <a href="https://zh.javascript.info/cookie#samesite" target="_blank" rel="noopener">Cookie，document.cookie</a>。</p>
<p>如果网站，例如 Facebook，在其身份验证 cookie 中具有 <code>samesite</code> 特性，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">Set-Cookie: authorization&#x3D;secret; samesite<br></code></pre></td></tr></table></figure>

<p>……那么，当在另一个网站中的 iframe 中打开 Facebook 时，此类 cookie 将不会被发送。因此，攻击将失败。</p>
<p>当不使用 cookie 时，<code>samesite</code> cookie 特性将不会有任何影响。这可以使其他网站能够轻松地在 iframe 中显示我们公开的、未进行身份验证的页面。</p>
<p>然而，这也可能会使得劫持攻击在少数情况下起作用。例如，通过检查 IP 地址来防止重复投票的匿名投票网站仍然会受到点击劫持的攻击，因为它不使用 cookie 对用户身份进行验证。</p>

        </div>

    </div>


</div>

</div>

<!--Now Write Bottom -->
<!--
 <div id="Bottom">
    <a href="/">
        <img src="/img/mail.png" class="BottomImg" >
    </a>
    <a href="/tags/BigNotes">
        <img src="/img/missioncontrol.png" class="BottomImg">
    </a>
    <a href="/archives">
        <img src="/img/reminders.png" class="BottomImg">
    </a>
    <a href="/photos">
        <img src="/img/preview.png" class="BottomImg">
    </a>




</div>
-->





<script src="/js/osx.js"></script>

</body>
</html>
