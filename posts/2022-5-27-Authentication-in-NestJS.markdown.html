<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/50425c9106578cba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50425c9106578cba.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c0ab723d8d52e6df.js" defer=""></script><script src="/_next/static/0LNQ5-5_oTWCkTMptLxbA/_buildManifest.js" defer=""></script><script src="/_next/static/0LNQ5-5_oTWCkTMptLxbA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">NestJS 认证与认证初步<img alt="open" src="/_next/static/media/down.9feac32f.png" width="480" height="480" decoding="async" data-nimg="1" class="post_iconSmall__5Hxz8" loading="lazy" style="color:transparent"/></div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="post_mdWarpper__Brjcd"><div class="markdown-body post_md__a6C1y"><h2 id="local-认证">Local 认证</h2>
<h4 id="首先准备包-passport">首先，准备包 Passport</h4>
<pre><code class="language-shell">yarn add @nestjs/passport passport passport-local
yarn add @types/passport-local
</code></pre>
<h4 id="创建-auth-模块和-user-模块">创建 Auth 模块和 User 模块</h4>
<p><strong>UserService需要做什么？</strong></p>
<p>提供用户数据。</p>
<p>User模块的创建没有太多标准，只需要是一个单例，提供用户数据即可。在实际应用中应该再这里构建用户模型和持久层。</p>
<p>其中，User模块需要提供用户数据并提供方法来返回用户数据，并且需要在模块中导出。</p>
<pre><code class="language-typescript">import { Module } from &#x27;@nestjs/common&#x27;;
import { UsersService } from &#x27;./users.service&#x27;;

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

</code></pre>
<p><strong>AuthService需要做什么？</strong></p>
<p><strong>提供认证的具体实现，提供JWT等......</strong></p>
<p>提供认证实现的一个例子：</p>
<pre><code class="language-typescript">import { Injectable } from &#x27;@nestjs/common&#x27;;
import { UsersService } from &#x27;../users/users.service&#x27;;

@Injectable()
export class AuthService {
  constructor(private readonly usersService: UsersService) {}

  async validateUser(username: string, pass: string): Promise&lt;any&gt; {
    const user = await this.usersService.findOne(username);
    if (user &amp;&amp; user.password === pass) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }
}

</code></pre>
<p><strong>在实际的应用程序中，我们不会以纯文本形式存储密码。 取而代之的是使用带有加密单向哈希算法的 <code>bcrypt</code> 之类的库。</strong></p>
<p>Auth 模块需要导入用户模块和PassportModule，用于认证。</p>
<p>Auth 模块的Provider 是 AuthService 和 LocalStrategy（用于提供认证策略）。</p>
<pre><code class="language-typescript">import { Module } from &#x27;@nestjs/common&#x27;;
import { AuthService } from &#x27;./auth.service&#x27;;
import { UsersModule } from &#x27;../users/users.module&#x27;;
import { PassportModule } from &#x27;@nestjs/passport&#x27;;
import { LocalStrategy } from &#x27;./local.strategy&#x27;;

@Module({
  imports: [UsersModule, PassportModule],
  providers: [AuthService, LocalStrategy],
})
export class AuthModule {}
</code></pre>
<h4 id="实现策略">实现策略</h4>
<p>在<code>local.strategy.ts</code> 中实现策略，策略的具体实现依赖于 AuthService</p>
<pre><code class="language-typescript">import { Strategy } from &#x27;passport-local&#x27;;
import { PassportStrategy } from &#x27;@nestjs/passport&#x27;;
import { Injectable, UnauthorizedException } from &#x27;@nestjs/common&#x27;;
import { AuthService } from &#x27;./auth.service&#x27;;

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly authService: AuthService) {
    super();
  }

  async validate(username: string, password: string): Promise&lt;any&gt; {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}

</code></pre>
<h3 id="local-认证-1">local 认证</h3>
<p><strong>别忘了导入 AuthModule ！</strong></p>
<p>在Controller 中引入 <code>@UseGuards</code></p>
<pre><code class="language-typescript">import { Controller, Request, Post, UseGuards } from &#x27;@nestjs/common&#x27;;
import { AuthGuard } from &#x27;@nestjs/passport&#x27;;

@Controller(&#x27;testguard&#x27;)
export class TestguardController {
  // 在这里引入需要的认证守卫！
  @UseGuards(AuthGuard(&#x27;local&#x27;))
  @Post(&#x27;auth/login&#x27;)
  async login(@Request() req) {
    return req.user;
  }
}

</code></pre>
<p>也可以将要使用的AuthGuard 写成一个类</p>
<pre><code class="language-typescript">import { Injectable } from &#x27;@nestjs/common&#x27;;
import { AuthGuard } from &#x27;@nestjs/passport&#x27;;

@Injectable()
export class LocalAuthGuard extends AuthGuard(&#x27;local&#x27;) {}
</code></pre>
<p>引入方式变为 <code>@UseGuards(LocalAuthGuard)</code></p>
<h2 id="jwt-方式">JWT 方式</h2>
<h3 id="jwt-生成">JWT 生成</h3>
<h4 id="引入包">引入包</h4>
<pre><code class="language-shell">yarn add @nestjs/jwt passport-jwt
yarn add @types/passport-jwt
</code></pre>
<h4 id="在-authservice-中加上-jwt">在 AuthService 中加上 JWT</h4>
<pre><code class="language-typescript">constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService, // 别忘了在这里实例化 JwtService
  ) {}

async login(user: any) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
</code></pre>
<p>我们使用 <code>@nestjs/jwt</code> 库，该库提供了一个 <code>sign()</code> 函数，用于从用户对象属性的子集生成 <code>jwt</code>，然后以简单对象的形式返回一个 <code>access_token</code> 属性。注意:我们选择 <code>sub</code> 的属性名来保持我们的 <code>userId</code> 值与<code>JWT</code> 标准一致。不要忘记将 <code>JwtService</code> 提供者注入到 <code>AuthService</code>中。</p>
<p>我们使用 <code>register()</code> 配置 <code>JwtModule</code> ，并传入一个配置对象。</p>
<h4 id="修改-authservice">修改 AuthService</h4>
<pre><code class="language-typescript">@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: jwtConstants.secret,
      signOptions: { expiresIn: &#x27;60s&#x27; },
    }),
  ],
  providers: [AuthService, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}
</code></pre>
<p>别忘了导出 <code>AuthService</code> 这样使用这个模块的Module 才能获取 <code>AuthService</code></p>
<h4 id="更新-controller">更新 Controller</h4>
<p>因为 Passport 定义的 <strong>所有策略</strong> 都是将validate() 方法执行的结果作为 user 属性存储在当前 <strong>HTTP Request 对象</strong> 上，所以我们可以得到 <code>username</code> 和 <code>userId</code>。</p>
<pre><code class="language-typescript">@Controller(&#x27;testguard&#x27;)
export class TestguardController {
  constructor(private readonly authService: AuthService) {}
  @UseGuards(LocalAuthGuard)
  @Post(&#x27;auth/login&#x27;)
  async login(@Request() req) {
    return this.authService.login(req.user);
  }
}
</code></pre>
<p>这样，我们就能得到 <code>AccessToken</code>。</p>
<p><code>POST localhost:3000/testguard/auth/login</code></p>
<p>x-www-form-urlencoded:<code>username=john&amp;passwoed=changeme</code></p>
<p>返回：</p>
<pre><code class="language-JSON">{&quot;access_token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG4iLCJzdWIiOjEsImlhdCI6MTY1MzY0MDUyMiwiZXhwIjoxNjUzNjQwNTgyfQ.gvMROxXrL_ywMDNf2IbReCxgrh6_FQYh10M34A8JxwM&quot;}
</code></pre>
<h3 id="jwt-认证">JWT 认证</h3>
<h4 id="编写-jwt-策略">编写 JWT 策略</h4>
<p><code>auth/jwt.strategy.ts</code></p>
<p>对于 <code>JWT</code> 策略，<code>Passport</code> 首先验证 <code>JWT</code> 的签名并解码 <code>JSON </code>。然后调用我们的 <code>validate()</code> 方法，该方法将解码后的 <code>JSON</code> 作为其单个参数传递。</p>
<p>所以，实际上我们的 <code>validate</code> 是拿到了解码后的 <code>JSON</code>，这个 <code>payload</code> 正是我们之前通过 <code>sign</code> 生成的。</p>
<p>所以我们只需要返回其内容。</p>
<pre><code class="language-typescript">import { ExtractJwt, Strategy } from &#x27;passport-jwt&#x27;;
import { PassportStrategy } from &#x27;@nestjs/passport&#x27;;
import { Injectable } from &#x27;@nestjs/common&#x27;;
import { jwtConstants } from &#x27;./constants&#x27;;

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtConstants.secret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
</code></pre>
<p><strong>在 <code>AuthModule</code> 中添加新的 <code>JwtStrategy</code> 作为提供者，因为现在我们提供了 JWT 作为认证方式</strong></p>
<pre><code class="language-typescript">@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: jwtConstants.secret,
      signOptions: { expiresIn: &#x27;60s&#x27; },
    }),
  ],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}
</code></pre>
<h4 id="然后引入这个策略">然后，引入这个策略</h4>
<p><code>jwt-auth.guard.ts</code></p>
<pre><code class="language-typescript">import { Injectable } from &#x27;@nestjs/common&#x27;;
import { AuthGuard } from &#x27;@nestjs/passport&#x27;;

@Injectable()
export class JwtAuthGuard extends AuthGuard(&#x27;jwt&#x27;) {}

</code></pre>
<h4 id="修改-controller">修改 Controller</h4>
<pre><code class="language-typescript">import { Controller, Request, Post, UseGuards, Get } from &#x27;@nestjs/common&#x27;;
import { AuthService } from &#x27;../auth/auth.service&#x27;;
import { LocalAuthGuard } from &#x27;../auth/local-auth.guard&#x27;;
import { JwtAuthGuard } from &#x27;../auth/jwt-auth.guard&#x27;;

@Controller(&#x27;testguard&#x27;)
export class TestguardController {
  constructor(private readonly authService: AuthService) {}

  @UseGuards(LocalAuthGuard)
  @Post(&#x27;auth/login&#x27;)
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Get(&#x27;info&#x27;)
  async getInfo(@Request() req) {
    return req.user;
  }
}

</code></pre>
<h4 id="测试">测试</h4>
<p>在 Get 时加上 请求头</p>
<pre><code>Authorization: Bearer [Access Token]
</code></pre>
<p>即可访问被 <code>JwtAuthGuard</code> 保护的数据。</p>
<h2 id="总结">总结</h2>
<p>实现认证总是需要编写以下模块：</p>
<p>1、<code>UserModule</code> ，作为用户数据的提供者（提供账号密码等）</p>
<p>2、<code>AuthModule</code>，用于提供认证策略，实现认证服务。</p>
<h3 id="usermodule-需要编写什么">UserModule 需要编写什么？</h3>
<h4 id="userservice">UserService</h4>
<p>获取用户数据的逻辑，<strong>这个模块需要导出并由<code>AuthService</code>引入</strong>。</p>
<h3 id="authmodule-需要编写什么">AuthModule 需要编写什么？</h3>
<h4 id="authservice">AuthService</h4>
<p>这个服务用于：具体实现local认证（因为密码可能散列），生成<code>JWT</code>（一般来说在生成<code>JWT</code>前已经由Local认证，并得到用户信息，这时候根据用户信息来生成<code>JWT</code>）</p>
<p>这个服务需要导入：<code>UserSercice</code>（用于Local认证），<code>JwtService</code>（用于生成<code>JWT</code>）</p>
<h4 id="authmodule">AuthModule</h4>
<p>需要导入的：<code>UserModule</code>（用于让Service可以拿到用户数据）、<code>PassportModule</code> （我们实现认证的库）、<code>JWTModule</code>（用于生成<code>JWT</code>，并配置<code>JWT</code>参数）</p>
<p>这个模块的提供者：<code>AuthService</code>（提供认证具体实现）、<code>LocalStrategy</code>， <code>JwtStrategy</code>（具体策略）</p>
<p>需要导出的：<code>AuthService</code>（为什么？因为我们需要这个服务来生成<code>JWT</code>，Controller 需要这个服务来获得 <code>JWT</code>并响应。</p>
<h4 id="编写策略">编写策略</h4>
<p>所有的策略都是继承 <code>PassportStrategy(Strategy)</code>，实现 <code>validate</code> 方法。</p>
<p><code>validate</code> 方法总是接受来自 <code>req</code> 的属性，返回的属性也会附加到 <code>req</code> 。一旦认证结束后，我们就可以从 <code>req</code>对象中拿到认证的结果。</p>
<p>策略的核心在于在发生错误的时候抛出 <code>UnauthorizedException()</code> 来告知无法认证，在认证通过的时候往 <code>req</code>对象上附加一些属性（这些属性可以用于返回，也可以用于生成 <code>JWT</code>）。</p>
<p>策略会调用 <code>AuthService</code> ，因为那里有认证的具体实现。</p>
<h4 id="收尾">收尾</h4>
<p>可以导出 <code>jwt-auth.guard.ts</code>、  <code>local-auth.guard.ts</code> 简化在Controller 使用 <code>@UseGuards</code>注解时要编写的代码。</p></div></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      NestJS 认证与认证初步\nintro:   \"\"\ndate:       2022-5-27 15:30:00\nauthor:     \"Mahiru\"\ncatalog: true\ntags:\n    - 工程开发\n---\n\n## Local 认证\n\n#### 首先，准备包 Passport\n\n```shell\nyarn add @nestjs/passport passport passport-local\nyarn add @types/passport-local\n```\n\n#### 创建 Auth 模块和 User 模块\n\n**UserService需要做什么？**\n\n提供用户数据。\n\nUser模块的创建没有太多标准，只需要是一个单例，提供用户数据即可。在实际应用中应该再这里构建用户模型和持久层。\n\n其中，User模块需要提供用户数据并提供方法来返回用户数据，并且需要在模块中导出。\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n\n```\n\n**AuthService需要做什么？**\n\n**提供认证的具体实现，提供JWT等......**\n\n提供认证实现的一个例子：\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private readonly usersService: UsersService) {}\n\n  async validateUser(username: string, pass: string): Promise\u003cany\u003e {\n    const user = await this.usersService.findOne(username);\n    if (user \u0026\u0026 user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}\n\n```\n\n**在实际的应用程序中，我们不会以纯文本形式存储密码。 取而代之的是使用带有加密单向哈希算法的 `bcrypt` 之类的库。**\n\nAuth 模块需要导入用户模块和PassportModule，用于认证。\n\nAuth 模块的Provider 是 AuthService 和 LocalStrategy（用于提供认证策略）。\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}\n```\n\n#### 实现策略\n\n在`local.strategy.ts` 中实现策略，策略的具体实现依赖于 AuthService\n\n```typescript\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private readonly authService: AuthService) {\n    super();\n  }\n\n  async validate(username: string, password: string): Promise\u003cany\u003e {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}\n\n```\n\n### local 认证\n\n**别忘了导入 AuthModule ！**\n\n在Controller 中引入 `@UseGuards`\n\n```typescript\nimport { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller('testguard')\nexport class TestguardController {\n  // 在这里引入需要的认证守卫！\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  async login(@Request() req) {\n    return req.user;\n  }\n}\n\n```\n\n也可以将要使用的AuthGuard 写成一个类\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class LocalAuthGuard extends AuthGuard('local') {}\n```\n\n引入方式变为 `@UseGuards(LocalAuthGuard)`\n\n## JWT 方式\n\n### JWT 生成\n\n#### 引入包\n\n```shell\nyarn add @nestjs/jwt passport-jwt\nyarn add @types/passport-jwt\n```\n\n#### 在 AuthService 中加上 JWT\n\n```typescript\nconstructor(\n    private readonly usersService: UsersService,\n    private readonly jwtService: JwtService, // 别忘了在这里实例化 JwtService\n  ) {}\n\nasync login(user: any) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n```\n\n我们使用 `@nestjs/jwt` 库，该库提供了一个 `sign()` 函数，用于从用户对象属性的子集生成 `jwt`，然后以简单对象的形式返回一个 `access_token` 属性。注意:我们选择 `sub` 的属性名来保持我们的 `userId` 值与`JWT` 标准一致。不要忘记将 `JwtService` 提供者注入到 `AuthService`中。\n\n我们使用 `register()` 配置 `JwtModule` ，并传入一个配置对象。\n\n#### 修改 AuthService\n\n```typescript\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n别忘了导出 `AuthService` 这样使用这个模块的Module 才能获取 `AuthService`\n\n#### 更新 Controller\n\n因为 Passport 定义的 **所有策略** 都是将validate() 方法执行的结果作为 user 属性存储在当前 **HTTP Request 对象** 上，所以我们可以得到 `username` 和 `userId`。\n\n```typescript\n@Controller('testguard')\nexport class TestguardController {\n  constructor(private readonly authService: AuthService) {}\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n}\n```\n\n这样，我们就能得到 `AccessToken`。\n\n`POST localhost:3000/testguard/auth/login`\n\nx-www-form-urlencoded:`username=john\u0026passwoed=changeme`\n\n返回：\n\n```JSON\n{\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG4iLCJzdWIiOjEsImlhdCI6MTY1MzY0MDUyMiwiZXhwIjoxNjUzNjQwNTgyfQ.gvMROxXrL_ywMDNf2IbReCxgrh6_FQYh10M34A8JxwM\"}\n```\n\n### JWT 认证\n\n#### 编写 JWT 策略\n\n`auth/jwt.strategy.ts`\n\n对于 `JWT` 策略，`Passport` 首先验证 `JWT` 的签名并解码 `JSON `。然后调用我们的 `validate()` 方法，该方法将解码后的 `JSON` 作为其单个参数传递。\n\n所以，实际上我们的 `validate` 是拿到了解码后的 `JSON`，这个 `payload` 正是我们之前通过 `sign` 生成的。\n\n所以我们只需要返回其内容。\n\n```typescript\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}\n```\n\n**在 `AuthModule` 中添加新的 `JwtStrategy` 作为提供者，因为现在我们提供了 JWT 作为认证方式**\n\n```typescript\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```\n\n#### 然后，引入这个策略\n\n`jwt-auth.guard.ts`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n\n```\n\n#### 修改 Controller\n\n```typescript\nimport { Controller, Request, Post, UseGuards, Get } from '@nestjs/common';\nimport { AuthService } from '../auth/auth.service';\nimport { LocalAuthGuard } from '../auth/local-auth.guard';\nimport { JwtAuthGuard } from '../auth/jwt-auth.guard';\n\n@Controller('testguard')\nexport class TestguardController {\n  constructor(private readonly authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('info')\n  async getInfo(@Request() req) {\n    return req.user;\n  }\n}\n\n```\n\n#### 测试\n\n在 Get 时加上 请求头\n\n```\nAuthorization: Bearer [Access Token]\n```\n\n即可访问被 `JwtAuthGuard` 保护的数据。\n\n## 总结\n\n实现认证总是需要编写以下模块：\n\n1、`UserModule` ，作为用户数据的提供者（提供账号密码等）\n\n2、`AuthModule`，用于提供认证策略，实现认证服务。\n\n### UserModule 需要编写什么？\n\n#### UserService\n\n获取用户数据的逻辑，**这个模块需要导出并由`AuthService`引入**。\n\n### AuthModule 需要编写什么？\n\n#### AuthService\n\n这个服务用于：具体实现local认证（因为密码可能散列），生成`JWT`（一般来说在生成`JWT`前已经由Local认证，并得到用户信息，这时候根据用户信息来生成`JWT`）\n\n这个服务需要导入：`UserSercice`（用于Local认证），`JwtService`（用于生成`JWT`）\n\n#### AuthModule\n\n需要导入的：`UserModule`（用于让Service可以拿到用户数据）、`PassportModule` （我们实现认证的库）、`JWTModule`（用于生成`JWT`，并配置`JWT`参数）\n\n这个模块的提供者：`AuthService`（提供认证具体实现）、`LocalStrategy`， `JwtStrategy`（具体策略）\n\n需要导出的：`AuthService`（为什么？因为我们需要这个服务来生成`JWT`，Controller 需要这个服务来获得 `JWT`并响应。\n\n#### 编写策略\n\n所有的策略都是继承 `PassportStrategy(Strategy)`，实现 `validate` 方法。\n\n`validate` 方法总是接受来自 `req` 的属性，返回的属性也会附加到 `req` 。一旦认证结束后，我们就可以从 `req`对象中拿到认证的结果。\n\n策略的核心在于在发生错误的时候抛出 `UnauthorizedException()` 来告知无法认证，在认证通过的时候往 `req`对象上附加一些属性（这些属性可以用于返回，也可以用于生成 `JWT`）。\n\n策略会调用 `AuthService` ，因为那里有认证的具体实现。\n\n#### 收尾\n\n可以导出 `jwt-auth.guard.ts`、  `local-auth.guard.ts` 简化在Controller 使用 `@UseGuards`注解时要编写的代码。\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2022-5-27-Authentication-in-NestJS.markdown"},"buildId":"0LNQ5-5_oTWCkTMptLxbA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>