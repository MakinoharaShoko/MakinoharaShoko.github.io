<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/50425c9106578cba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50425c9106578cba.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c0ab723d8d52e6df.js" defer=""></script><script src="/_next/static/_PQfbmLHnVN3d0QW7vZpv/_buildManifest.js" defer=""></script><script src="/_next/static/_PQfbmLHnVN3d0QW7vZpv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">计算机组成复习<img alt="open" src="/_next/static/media/down.9feac32f.png" width="480" height="480" decoding="async" data-nimg="1" class="post_iconSmall__5Hxz8" loading="lazy" style="color:transparent"/></div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="post_mdWarpper__Brjcd"><div class="markdown-body post_md__a6C1y"><h1 id="计算机技术指标">计算机技术指标</h1>
<h2 id="cpu执行时间">CPU执行时间：</h2>
<p>$$Te = m/F$$</p>
<p>$$Te = m*T$$</p>
<p>m：CPU时钟周期数；T：时钟周期；F：频率</p>
<h2 id="cpi-每条指令平均时钟周期数">CPI 每条指令平均时钟周期数：</h2>
<p>$$CPI = m/IC$$</p>
<p>$$CPI = \sum\limits_{i=1}^N (CPI_i*IC_i)/IC$$</p>
<p>IC：指令条数(总的)</p>
<h2 id="mips每秒百万条指令数">MIPS每秒百万条指令数：</h2>
<p>$$MIPS = IC/(Te*10^6)$$</p>
<p>$$MIPS = F/(CPI*10^6)$$</p>
<h1 id="存储系统">存储系统</h1>
<h2 id="半导体容量扩展">半导体容量扩展：</h2>
<p>1.线选法</p>
<p>用一根地址线选择一块芯片</p>
<p>2.全译码法</p>
<p>将全部地址线译码，地位直接用于片内寻址，高位用译码器译码后进行片选。（地址唯一、连续、没有地址重叠）</p>
<p>3.部分译码法：</p>
<p>将高位地址的部分地址线用于译码，部分不参与译码（所以可能会产生地址重叠，比如最高位为1和为0选择同一芯片，所以地址就重叠了）。</p>
<h3 id="拓展方式">拓展方式：</h3>
<p>1.位拓展方式</p>
<p>拓展每个字的位数</p>
<p>将芯片的地址线、片选信号和读写控制并联（视为一个芯片），然后将数据线分别连到各个芯片。</p>
<p>2.字拓展方式</p>
<p>拓展字数</p>
<p>将芯片的地址线、数据线和读写控制并联，然后将片选信号连到各个芯片。</p>
<p>3.字位拓展方式</p>
<p>同时拓展字数和位数</p>
<p>将所有芯片的读写控制线连到一起</p>
<p>将同一区域（位扩展）的芯片片选信号连到一起，不同区域的片选信号分开</p>
<p>将同一区域中不同芯片的数据线分别连接到应有的位置上</p>
<h2 id="cache">Cache：</h2>
<p>读：</p>
<p>CPU发出读请求后，先由Cache控制器判断请求的字是否在Cache中，若命中，则对Cache读，否则从主存读所需字送CPU，并把该字所在块送Cache，如果Cache已满，则调用替换算法。</p>
<p>写：</p>
<p>1、写直达：</p>
<p>在写数据时既写入主存又写入Cache。</p>
<p>2、写回法：</p>
<p>在写入数据时先写入Cache，直到该块被替换时才写入主存。每个块需要设置一个“修改位”来判断是否要将这个块存回主存原来位置。</p>
<h3 id="cache主存地址映像与变换">Cache主存地址映像与变换</h3>
<p>1.全相连映像：</p>
<p>将主存中的块映射到Cache中的任意一块，使用相联存储器按内容寻址。</p>
<pre><code>主存:   主存块号+块内地址
          ↓      ↓
查不到  ←相连比较   ↓
         ↓       ↓
        查到      ↓
         ↓       ↓
Cache: Cache块号+块内地址
</code></pre>
<p>2.直接映像：</p>
<p>将主存映射到Cache中的一个固定块位置</p>
<p>$$i = j mod C $$</p>
<p>$$i = j mod 2^c$$</p>
<p>i:Cache块号；j:主存块号 C:块数 c：Cache位数</p>
<pre><code>主存：主存字块标记(t位)+Cache字块地址(c位)+块内地址(b位)
Cache：块号(c位)+块内地址(b位)
其中，在主存通过Cache字块地址找到对应到Cache中哪一块后，
再通过标记表的t位标记是否和主存字块t位标记相等判断是否命中。
</code></pre>
<p>3.组相连映像：</p>
<p>先把Cache分为Q组，每组R块</p>
<p>$$k = j\ mod\ Q$$</p>
<p>k:Cache组号；j:主存块号</p>
<p>块号为j的主存块影响到Cache中的块号为：</p>
<p>$$i = k*2^r+h$$</p>
<p>$$2^r$$:组内块号。r= 1, 每组2块；h:组内偏移，这个值是随机的，由于主存的一块会映射到Cache某组的任意一块。</p>
<p>r=0:每组1块，此时直接映像；r=c:每组$$2^c$$块，也就是只分一组，此时组内块号就是块号（Cache块号与主存块号），此时为全相连映像。</p>
<pre><code>主存:主存字块标记(t+r)+组号(c-r)+块内地址(b)
         ↓         ↓            ↓ 
      相联比较↘     ↓            ↓
         ←←←←←←←←←←←            ↓             
         ↓       ↘              ↓ 
Cache:组号(c-r)+组内块号(r)+块内地址(b)

备注：r越大，组越少，r=c，全是主存字块标记，此时全相连;
r=0，组号为c，此时组号等同于块号(每组只有一块)，而主存的t位标记仍然通过标记表的t位比较是否相等，相等则命中。
</code></pre>
<pre><code>在此种模式中，每组有一个相连比较表（只有一组就只有一个，即全相连），
首先先得出是哪一组的相连比较表，用主存标记t位相连比较，如相等，则得出组内块号，命中，如不相等，失效。

主要思想：分组进行组内的全相连，c=0就是只分一组，也就是正统的全相连。
</code></pre>
<h1 id="指令系统">指令系统</h1>
<p>1、指令根据操作码数目分为零地址、一地址、二地址、三地址指令等。</p>
<h2 id="指令系统设计">指令系统设计</h2>
<p>固定长编码：所有操作码的长度都是相等的。</p>
<p>Huffman编码：根据指令的出现概率编码，概率大的长，概率小的短。</p>
<p>编码过程：按出现概率自左向右排序，然后抽出概率最低的两个形成一个树，根节点是两者之和。然后重复，直到根节点概率为1。</p>
<p>指令由Huffman树确定，左边的子节点为0，右边为1，以此类推。</p>
<h3 id="扩展编码">扩展编码：</h3>
<p>a/b(m-n)扩展编码：a、b是有相同长度的编码数目，m、n是码长。</p>
<p>比如2/7、2-4代表的是同一种编码。</p>
<p>其中，比较短的编码的全1（比如：1111）一般用于作为前缀，代表切换至更长长度的编码。</p>
<p>算编码数：以编码为3-6-9-扩展编码为例</p>
<p>$$S_9 = ((2^3-S_3)\cdot2^{6-3}-S_6)\cdot2^{9-6}$$</p>
<p>其中，Sn代表码长为n的编码数目。</p>
<p>解释：$$2^3-S_3$$ 表示了在表示完码长为3的编码后，剩余的前缀数目。这些前缀可以用来拓展到6位。如果剩余的前缀越多，可以拓展出的组也就越多，然后再乘以每组可以表示的6码长编码数目（由于前3位是前缀，实际上只有$$2^{6-3}$$种结果），得到一共可以表示多少码长为6编码，再减去实际的，得到前缀数，以此类推，得到码长为9的编码可以表示的数目。</p>
<h1 id="控制器">控制器</h1>
<h2 id="控制器基础">控制器基础</h2>
<h3 id="控制器组成">控制器组成</h3>
<p>程序计数器PC：存指令的地址</p>
<p>指令寄存器IR：保存指令的内容</p>
<p>指令译码器ID：分析识别是怎样的指令</p>
<p>地址形成部件：根据不同的寻址方式形成操作数的有效地址。</p>
<p>脉冲源：作为时钟脉冲</p>
<p>启停线路：计算机启动信号，启动后时钟脉冲才能进入，然后启动节拍信号发生器开始工作。</p>
<p>节拍信号发生器：将脉冲转换为各个设备所需要的节拍信号</p>
<p>控制单元：将指令发出的各种控制信号按节拍分配。</p>
<p>中断控制逻辑：控制中断。</p>
<h3 id="寄存器">寄存器：</h3>
<p>通用+PC+IR+AR（记录主存单元地址）+DR（数据缓冲寄存器，在CPU和主存间形成缓冲）+PSW（记录各种条件码，比如进位）</p>
<h2 id="微程序控制">微程序控制</h2>
<h3 id="关于容量">关于容量：</h3>
<p>CS容量：$$2^{N_{AR}} \cdot N_{IR} $$，前者代表多少指令，后者代表每条指令多少位</p>
<p>IR位数：微程序位数，否则放不下</p>
<p>AR位数：下址位数</p>
<h3 id="微指令编码方式">微指令编码方式：</h3>
<p>直接控制法：每一位代表一个微命令</p>
<p>字段直接编译法：</p>
<p>1、微命令数=$$2^n-1$$，因000要代表不发出微命令。</p>
<p>2、每个互斥类可能有多个编码，但是互斥类之间是平行排布的，平铺在控制字段。下址字段则是固定的，存下条指令地址。</p>
<p>例如：</p>
<pre><code>组1|组2|组3|......|判别码|下址|
每个组是一个互斥类，代表2^n-1个指令。
</code></pre>
<h3 id="微指令执行方式">微指令执行方式：</h3>
<p>串行方式：在一条微指令执行完毕后才会执行下一条</p>
<p>并行方式：在一条微指令执行时，就取下一条微指令</p></div></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"计算机组成复习\"\nintro:   \"\"\ndate:       2021-7-9 21:00:01\nauthor:     \"Makinohara\"\ncatalog: true\ntags:\n    - 计算机基础\n    \n---\n\n# 计算机技术指标\n\n## CPU执行时间：\n\n$$Te = m/F$$\n\n$$Te = m*T$$\n\nm：CPU时钟周期数；T：时钟周期；F：频率\n\n## CPI 每条指令平均时钟周期数：\n\n$$CPI = m/IC$$\n\n$$CPI = \\sum\\limits_{i=1}^N (CPI_i*IC_i)/IC$$\n\nIC：指令条数(总的)\n\n## MIPS每秒百万条指令数：\n\n$$MIPS = IC/(Te*10^6)$$\n\n$$MIPS = F/(CPI*10^6)$$\n\n# 存储系统\n\n## 半导体容量扩展：\n\n1.线选法\n\n用一根地址线选择一块芯片\n\n2.全译码法\n\n将全部地址线译码，地位直接用于片内寻址，高位用译码器译码后进行片选。（地址唯一、连续、没有地址重叠）\n\n3.部分译码法：\n\n将高位地址的部分地址线用于译码，部分不参与译码（所以可能会产生地址重叠，比如最高位为1和为0选择同一芯片，所以地址就重叠了）。\n\n### 拓展方式：\n\n1.位拓展方式\n\n拓展每个字的位数\n\n将芯片的地址线、片选信号和读写控制并联（视为一个芯片），然后将数据线分别连到各个芯片。\n\n2.字拓展方式\n\n拓展字数\n\n将芯片的地址线、数据线和读写控制并联，然后将片选信号连到各个芯片。\n\n3.字位拓展方式\n\n同时拓展字数和位数\n\n将所有芯片的读写控制线连到一起\n\n将同一区域（位扩展）的芯片片选信号连到一起，不同区域的片选信号分开\n\n将同一区域中不同芯片的数据线分别连接到应有的位置上\n\n## Cache：\n\n读：\n\nCPU发出读请求后，先由Cache控制器判断请求的字是否在Cache中，若命中，则对Cache读，否则从主存读所需字送CPU，并把该字所在块送Cache，如果Cache已满，则调用替换算法。\n\n写：\n\n1、写直达：\n\n在写数据时既写入主存又写入Cache。\n\n2、写回法：\n\n在写入数据时先写入Cache，直到该块被替换时才写入主存。每个块需要设置一个“修改位”来判断是否要将这个块存回主存原来位置。\n\n### Cache主存地址映像与变换\n\n1.全相连映像：\n\n将主存中的块映射到Cache中的任意一块，使用相联存储器按内容寻址。\n\n```\n主存:   主存块号+块内地址\n          ↓      ↓\n查不到  ←相连比较   ↓\n         ↓       ↓\n        查到      ↓\n         ↓       ↓\nCache: Cache块号+块内地址\n```\n\n2.直接映像：\n\n将主存映射到Cache中的一个固定块位置\n\n$$i = j mod C $$\n\n$$i = j mod 2^c$$\n\ni:Cache块号；j:主存块号 C:块数 c：Cache位数\n\n```\n主存：主存字块标记(t位)+Cache字块地址(c位)+块内地址(b位)\nCache：块号(c位)+块内地址(b位)\n其中，在主存通过Cache字块地址找到对应到Cache中哪一块后，\n再通过标记表的t位标记是否和主存字块t位标记相等判断是否命中。\n```\n\n3.组相连映像：\n\n先把Cache分为Q组，每组R块\n\n$$k = j\\ mod\\ Q$$\n\nk:Cache组号；j:主存块号\n\n块号为j的主存块影响到Cache中的块号为：\n\n$$i = k*2^r+h$$\n\n$$2^r$$:组内块号。r= 1, 每组2块；h:组内偏移，这个值是随机的，由于主存的一块会映射到Cache某组的任意一块。\n\nr=0:每组1块，此时直接映像；r=c:每组$$2^c$$块，也就是只分一组，此时组内块号就是块号（Cache块号与主存块号），此时为全相连映像。\n\n```\n主存:主存字块标记(t+r)+组号(c-r)+块内地址(b)\n         ↓         ↓            ↓ \n      相联比较↘     ↓            ↓\n         ←←←←←←←←←←←            ↓             \n         ↓       ↘              ↓ \nCache:组号(c-r)+组内块号(r)+块内地址(b)\n\n备注：r越大，组越少，r=c，全是主存字块标记，此时全相连;\nr=0，组号为c，此时组号等同于块号(每组只有一块)，而主存的t位标记仍然通过标记表的t位比较是否相等，相等则命中。\n```\n\n```\n在此种模式中，每组有一个相连比较表（只有一组就只有一个，即全相连），\n首先先得出是哪一组的相连比较表，用主存标记t位相连比较，如相等，则得出组内块号，命中，如不相等，失效。\n\n主要思想：分组进行组内的全相连，c=0就是只分一组，也就是正统的全相连。\n```\n\n# 指令系统\n\n1、指令根据操作码数目分为零地址、一地址、二地址、三地址指令等。\n\n## 指令系统设计\n\n固定长编码：所有操作码的长度都是相等的。\n\nHuffman编码：根据指令的出现概率编码，概率大的长，概率小的短。\n\n编码过程：按出现概率自左向右排序，然后抽出概率最低的两个形成一个树，根节点是两者之和。然后重复，直到根节点概率为1。\n\n指令由Huffman树确定，左边的子节点为0，右边为1，以此类推。\n\n### 扩展编码：\n\na/b(m-n)扩展编码：a、b是有相同长度的编码数目，m、n是码长。\n\n比如2/7、2-4代表的是同一种编码。\n\n其中，比较短的编码的全1（比如：1111）一般用于作为前缀，代表切换至更长长度的编码。\n\n算编码数：以编码为3-6-9-扩展编码为例\n\n$$S_9 = ((2^3-S_3)\\cdot2^{6-3}-S_6)\\cdot2^{9-6}$$\n\n其中，Sn代表码长为n的编码数目。\n\n解释：$$2^3-S_3$$ 表示了在表示完码长为3的编码后，剩余的前缀数目。这些前缀可以用来拓展到6位。如果剩余的前缀越多，可以拓展出的组也就越多，然后再乘以每组可以表示的6码长编码数目（由于前3位是前缀，实际上只有$$2^{6-3}$$种结果），得到一共可以表示多少码长为6编码，再减去实际的，得到前缀数，以此类推，得到码长为9的编码可以表示的数目。\n\n# 控制器\n\n## 控制器基础\n\n### 控制器组成\n\n程序计数器PC：存指令的地址\n\n指令寄存器IR：保存指令的内容\n\n指令译码器ID：分析识别是怎样的指令\n\n地址形成部件：根据不同的寻址方式形成操作数的有效地址。\n\n脉冲源：作为时钟脉冲\n\n启停线路：计算机启动信号，启动后时钟脉冲才能进入，然后启动节拍信号发生器开始工作。\n\n节拍信号发生器：将脉冲转换为各个设备所需要的节拍信号\n\n控制单元：将指令发出的各种控制信号按节拍分配。\n\n中断控制逻辑：控制中断。\n\n### 寄存器：\n\n通用+PC+IR+AR（记录主存单元地址）+DR（数据缓冲寄存器，在CPU和主存间形成缓冲）+PSW（记录各种条件码，比如进位）\n\n## 微程序控制\n\n### 关于容量：\n\nCS容量：$$2^{N_{AR}} \\cdot N_{IR} $$，前者代表多少指令，后者代表每条指令多少位\n\nIR位数：微程序位数，否则放不下\n\nAR位数：下址位数\n\n### 微指令编码方式：\n\n直接控制法：每一位代表一个微命令\n\n字段直接编译法：\n\n1、微命令数=$$2^n-1$$，因000要代表不发出微命令。\n\n2、每个互斥类可能有多个编码，但是互斥类之间是平行排布的，平铺在控制字段。下址字段则是固定的，存下条指令地址。\n\n例如：\n\n```\n组1|组2|组3|......|判别码|下址|\n每个组是一个互斥类，代表2^n-1个指令。\n```\n\n### 微指令执行方式：\n\n串行方式：在一条微指令执行完毕后才会执行下一条\n\n并行方式：在一条微指令执行时，就取下一条微指令\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-7-9-计算机组成复习.markdown"},"buildId":"_PQfbmLHnVN3d0QW7vZpv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>