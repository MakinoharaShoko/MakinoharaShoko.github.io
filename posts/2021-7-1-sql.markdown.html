<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/50425c9106578cba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50425c9106578cba.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-5a551d2ae83cd097.js" defer=""></script><script src="/_next/static/MkjpXAVhBc5OxoeFL-xod/_buildManifest.js" defer=""></script><script src="/_next/static/MkjpXAVhBc5OxoeFL-xod/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">数据库复习<img alt="open" src="/_next/static/media/down.9feac32f.png" width="480" height="480" decoding="async" data-nimg="1" class="post_iconSmall__5Hxz8" loading="lazy" style="color:transparent"/></div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="post_mdWarpper__Brjcd"><div class="markdown-body post_md__a6C1y"><h1 id="sql语句">SQL语句</h1>
<p>1、创建与删除</p>
<pre><code class="language-sql">#数据库
create database 数据库;
drop database 数据库;

#表
create table table1 (
    学号 char(4) primary key,
    姓名 char(20) not null
)

#索引
create unique index idx on S(Sno DESC);#降序排列

#视图
create view view_name as
select * from s where city = &#x27;New York&#x27;;
drop view view_name;

#角色
create role role_name;
grant all privileges on S to role_name with grant option;
drop role role_name;

#索引：
create [unique|cluster(聚集)]index Index_name on S(Sno);
drop index index_name;
</code></pre>
<p>2、查询与修改</p>
<pre><code class="language-sql">#基本查询
select Sno from S;

#带别名
select Sno 学号 , Grade 成绩 , joinGroup 加入社团 from S;

#带条件
select Sno from S where Sage &gt; 18;
select Sno from S where Sage between 18 and 20;
select Sno from S where name not in (&#x27;Yukinoshita&#x27;,&#x27;Yui&#x27;);
select Sno from S where name like &#x27;Yukinoshita%&#x27;;
select Sno from S where joinGroup is not null;

#带排序
select Sno from S order by Grade DESC;
select top 10 Sno from S order by Grade DESC;#选择前10名的学生。

#聚集
select avg(Grade) from S;
select count(*) from S;
select count(distinct joinGroup) from S;#相同内容只计数一次
select Sno from S group by Sno having count(distinct chooseClass) &gt; 3;

#连接
select S.* , SC.* from S,SC where S.Cno = SC.Cno;
select S.Sno , S.name , S.city , SPJ.qty from s , SPJ 
where S.Sno = SPJ.Sno and SPJ.Jno = &#x27;J001&#x27; and SPJ.qty &gt;300;

#嵌套
select Sname from S where Sno in (select Sno from SC where Cno = &#x27;1001&#x27;);


</code></pre>
<p>3、修改</p>
<pre><code class="language-sql">#插入
insert into S values(&#x27;114514&#x27;,&#x27;李田所&#x27;,&#x27;C&#x27;,&#x27;回家部&#x27;,&#x27;24&#x27;);
select * into S from 下北泽高 where Sname like &#x27;李田所&#x27;;#把信息复制到大学

#修改
update S set Grade = &#x27;B&#x27; where Sno = 114514;

#删除
delete from S where Sno = 114514;

#批量
update S set Sage = Sage +1 ;

#带子查询
update SPJ set QTY = QTY - 50 where JNO in( select JNO from J 
                                           where City = &#x27;天津&#x27;);
  
#alter
alter table tableName drop column columnName;#删除列
alter table tableName add column Sbirth char(20);#添加列
alter table tableName alter column columnname datatype# 改变数据类型

#drop
drop table user index role ......;#drop一般删除数据结构或对象（包括属性列）		，
#而delete则倾向于删除对象中的元组。
</code></pre>
<p>4、视图</p>
<pre><code class="language-sql">#创建
create view S_BJ_VIEW as 
select * from S where city = &#x27;北京&#x27; with check option;

#删除
drop view ViewName;

#查询
select Sno,Sname from S_BJ_VIEW where STAT &gt; &#x27;B&#x27;;
select * from S_AVGQTY where QAVG &gt;=300;

#视图消解法：
#定义的视图：
create view S_AVGQTY(SNO,PNO,QAVG)
as select SNO,PNO,AVG(QTY) from SPJ group by SNO,PNO;
#查询语句：select * from S_AVGQTY where QAVG &gt;=300;
select * from S_AVGQTY where QAVG &gt;=300;
#转换后：
select SNO,PNO,AVG(QTY) from SPJ group by SNO,PNO having AVG(QTY)&gt;=300;

#更新数据：
insert into S_BJ_VIEW value(&#x27;S7&#x27;,&#x27;北京114514电子厂&#x27;,&#x27;B&#x27;,&#x27;北京&#x27;);

#删除：
delete from S_BJ_VIEW where SNAME = &#x27;北京114514电子厂&#x27;;
</code></pre>
<p>5、安全性</p>
<pre><code class="language-sql">#创建用户
create user userName for login loginName with default_schema = schName;
create login loginName with password = ..., default_database = DB_NAME;

#创建角色
create role RoleName; 
grant RoleName to UserName with admin option;

#权限管理
grant all privileges on S to Rolename/Username; #with grant option:可以传递权限
revoke all privileges on S from Rolename/Username;
deny update on S to Rolename/Username;#拒绝这一权限，使其加入其他有update权限组后仍然不能执行该操作。
</code></pre>
<p>6、完整性：</p>
<pre><code class="language-sql">#主码定义：
create table s(
    Sno char(4) primary key;
    ......
)

create table s(
    ......
    primary key (Sno);
)
create table s (
	......
    primary key(Sno,Pno,Jno);
)

#参照完整性：
create table s(
	......
    foreign key (SNO) references s(SNO);
)

#其他完整性：
not null #非空
unique # 唯一
default &#x27;defaultValue&#x27; #默认值

#check约束
create table s(
	......
    STAT Char(2) check(STAT in (&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)),
    ......
)

#constraint命令
create table s (
	......
    Sname char(20) constraint c1 not null # 此时c1这一完整性约束(constraint)的值为not null
)
alter table s drop constraint c1;
alter table s add constraint c2 check(......);

</code></pre>
<h1 id="数据库概念复习">数据库概念复习</h1>
<h2 id="关系运算">关系运算</h2>
<p>1、选择</p>
<p>$$\sigma(R)_F={t|t \in R\wedge F(t) = true}$$</p>
<p>2、投影</p>
<p>$$\Pi_A(R)={t[A]|t \in R}$$</p>
<p>3、连接</p>
<p>等值连接：选取笛卡尔级中等值的那些元组</p>
<p>自然连接：在等值连接的基础上去掉重复的属性列</p>
<p>4、除运算</p>
<p>R÷S:</p>
<p>用于选出以下内容：</p>
<p>属性：在R不在S的属性</p>
<p>元组：删去的属性对得上在R中的值</p>
<p>比如：</p>
<p>R:</p>
<p>Sno Jno</p>
<p>a      1</p>
<p>b      2</p>
<p>c      3</p>
<p>S:</p>
<p>1</p>
<p>3</p>
<p>R÷S:</p>
<p>Sno</p>
<p>a</p>
<p>c</p>
<p><strong>其他较为重要的运算：交并减、笛卡尔积</strong></p>
<h2 id="数据库安全">数据库安全</h2>
<h3 id="自主">自主：</h3>
<p>授予权限的类型：</p>
<table><thead><tr><th>基本表、视图</th><th>属性列</th></tr></thead><tbody><tr><td>select insert update delete references all privileges</td><td>select insert update references all privileges</td></tr></tbody></table>
<p>一个简单的例子：</p>
<p>grant update(Sno),select on table SC to User1;</p>
<p>对属性列：权限后面加括号，表明该权限生效的属性列</p>
<p>可传递：with grant option;</p>
<p>收回权限：同grant，但有需要注意的地方：</p>
<p>最后加 cascade/restrict：是否级联操作或约束操作。</p>
<p>角色：</p>
<p>创建：create role rolename ;</p>
<p>授予权限同用户</p>
<p>将角色权限授予用户：grant Rolename to User;</p>
<p>解除权限：revoke Rolename from User;</p>
<p>撤销授权同用户</p>
<h3 id="强制">强制：</h3>
<p>设定若干级别：</p>
<p>TS&gt;=S&gt;=C&gt;=P</p>
<p>访问规则：</p>
<p>主体许可证等级大于等于客体，可以读。</p>
<p>主体许可证等级小于等于客体，可以写。</p>
<p>第二条解释：高许可证主体没有办法写出一个更低等级的客体。</p>
<p>视图：</p>
<p>create view as(select......);</p>
<p>grant select on view to ......;</p>
<h2 id="完整性">完整性：</h2>
<p>实体完整性：</p>
<pre><code class="language-sql">create table ...(
    ......
    Sname char(20) primary key;#在列级
    
    ......
    primary key (Sname);#在表级
    
    primary key (Sname,Sno);#在表级，多列

)
</code></pre>
<p>参照完整性：</p>
<pre><code class="language-sql">create table S2(
    ......
    foreign key (Sno) references S(Sno)#表级定义参照完整性
    on delete cascade on update cascade,#级联删除、更新
)
</code></pre>
<p>约束语句：</p>
<pre><code class="language-sql">create table R1(
    Sno char(20) not null,#非空
    ...... unique,#列值唯一
    ......check( ......in(......集合))
    
    check (Ssex = &#x27;female&#x27;or Sname not like &#x27;Ms.%&#x27;);
    
    
    #constraint
    Sno char(20) constraint C1 check(......);#形成一个名为C1的约束条件
    
    ......
    constraint C2 check(......)#在表级定义约束条件
)

alter table R1 drop constraint C1;#删除约束条件
alter table R1 create constraint c3 check(......);#创建约束条件，表级。
</code></pre>
<h3 id="断言">断言</h3>
<p>在操作时，使断言不为真的操作拒绝执行。</p>
<p>创建断言：</p>
<pre><code class="language-sql">create assertion assertion_name check (......);

create assertion A1 check(60&gt;=select count(*) from SC where C = &#x27;Cource1&#x27;);
create assertion A2 check(60&gt;=all(select count(*) from SC group by ...));
</code></pre>
<h3 id="触发器">触发器：</h3>
<p>触发器用于在某条件由于操作成立时触发其他操作。</p>
<pre><code class="language-sql">create trigger trigger_name before/after update on SC
referencing new/old row as variable#触发器内设变量：原值和新值
for each row / statement#每行触发还是每条语句触发
when(......)#触发条件，比如new.grade&gt;=old.grade
insert into Table_name(......) values (......)

drop trigger trigger_name;#删除（删除对象用drop）
</code></pre>
<h2 id="规范化">规范化</h2>
<p>1NF：不可分割</p>
<p>2NF：属性由一码确定</p>
<p>3NF：没有不完全函数依赖，没有传递函数依赖</p>
<p>BCNF：每个决定因素都有码</p>
<p>4NF：不存在非平凡、非函数依赖的多值依赖</p>
<p>规范化的实质：概念的单一化</p>
<h2 id="数据库设计">数据库设计</h2>
<h3 id="e-r图">E-R图</h3>
<p>联系：菱形，两侧写是1-1、1-n还是n-1的依赖。</p>
<p>属性：圆形，属性不能有属性（不可再分）</p>
<p>实体：矩形</p>
<h3 id="实体描述">实体描述：</h3>
<p>实体{实体的主码（下划线），属性1，属性2，属性3}</p>
<h2 id="数据库的故障恢复数据库的并发控制">数据库的故障恢复、数据库的并发控制：</h2>
<h3 id="事务">事务</h3>
<p>事务：一个数据库操作序列，具有ACID特性，即原子性、一致性、隔离性、持续性（永久性）</p>
<h3 id="数据库的日志文件">数据库的日志文件</h3>
<p>日志文件记录：</p>
<p>事务标识、操作类型、操作对象、操作前值、操作后值。</p>
<h3 id="故障处理">故障处理</h3>
<p>事务故障：反向扫描日志文件，撤销已经完成的操作</p>
<p>系统故障：视事务完成情况选择是撤销还是重做，撤销：根据日志写更新前值；重做：根据日志写更新后值。</p>
<p>介质故障：从恢复介质重装数据，然后重做已经完成的事务。</p>
<h3 id="并发控制">并发控制</h3>
<h4 id="封锁">封锁</h4>
<p>X锁（写锁）：上X锁后，其他事务不能读写。</p>
<p>S锁（读锁）：上S锁后，其他事务可以再上S锁，可以读，但是不能写。</p>
<h5 id="封锁协议">封锁协议</h5>
<p>一级封锁协议：事务在修改数据前必须加X锁，直至事务结束释放。</p>
<p>二级封锁协议：在一级的基础上，事务读要上S锁，读完释放。</p>
<p>三级封锁协议：在一级的基础上，事务读要上S锁，且事务结束时才释放（解决了不可重复读问题）。</p>
<h3 id="活锁与死锁">活锁与死锁</h3>
<p>活锁：事务由于等待其他事务结束无法完成（解决：先来先服务）。</p>
<p>死锁：事务间循环等待导致数个事务不能结束（解决：采取措施避免或每隔一段时间诊断死锁并清除）。</p>
<h3 id="意向锁intention-lock">意向锁（Intention Lock）</h3>
<p>IS锁：对一个对象加IS锁，意味着拟对其后裔结点加S锁。如果要对某个元组加S锁，必须先给关系加IS锁。</p>
<p>IX锁：类似IS锁</p>
<p>SIX锁：对这个对象加S锁，然后加IX锁，代表这个事务希望读这个对象，并可能更新个别元组。</p></div></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"数据库复习\"\nintro:   \"\"\ndate:       2021-7-1 21:00:01\nauthor:     \"Makinohara\"\ncatalog: true\ntags:\n    - 计算机基础\n    \n---\n\n# SQL语句\n\n1、创建与删除\n\n```sql\n#数据库\ncreate database 数据库;\ndrop database 数据库;\n\n#表\ncreate table table1 (\n    学号 char(4) primary key,\n    姓名 char(20) not null\n)\n\n#索引\ncreate unique index idx on S(Sno DESC);#降序排列\n\n#视图\ncreate view view_name as\nselect * from s where city = 'New York';\ndrop view view_name;\n\n#角色\ncreate role role_name;\ngrant all privileges on S to role_name with grant option;\ndrop role role_name;\n\n#索引：\ncreate [unique|cluster(聚集)]index Index_name on S(Sno);\ndrop index index_name;\n```\n\n2、查询与修改\n\n```sql\n#基本查询\nselect Sno from S;\n\n#带别名\nselect Sno 学号 , Grade 成绩 , joinGroup 加入社团 from S;\n\n#带条件\nselect Sno from S where Sage \u003e 18;\nselect Sno from S where Sage between 18 and 20;\nselect Sno from S where name not in ('Yukinoshita','Yui');\nselect Sno from S where name like 'Yukinoshita%';\nselect Sno from S where joinGroup is not null;\n\n#带排序\nselect Sno from S order by Grade DESC;\nselect top 10 Sno from S order by Grade DESC;#选择前10名的学生。\n\n#聚集\nselect avg(Grade) from S;\nselect count(*) from S;\nselect count(distinct joinGroup) from S;#相同内容只计数一次\nselect Sno from S group by Sno having count(distinct chooseClass) \u003e 3;\n\n#连接\nselect S.* , SC.* from S,SC where S.Cno = SC.Cno;\nselect S.Sno , S.name , S.city , SPJ.qty from s , SPJ \nwhere S.Sno = SPJ.Sno and SPJ.Jno = 'J001' and SPJ.qty \u003e300;\n\n#嵌套\nselect Sname from S where Sno in (select Sno from SC where Cno = '1001');\n\n\n```\n\n3、修改\n\n```sql\n#插入\ninsert into S values('114514','李田所','C','回家部','24');\nselect * into S from 下北泽高 where Sname like '李田所';#把信息复制到大学\n\n#修改\nupdate S set Grade = 'B' where Sno = 114514;\n\n#删除\ndelete from S where Sno = 114514;\n\n#批量\nupdate S set Sage = Sage +1 ;\n\n#带子查询\nupdate SPJ set QTY = QTY - 50 where JNO in( select JNO from J \n                                           where City = '天津');\n  \n#alter\nalter table tableName drop column columnName;#删除列\nalter table tableName add column Sbirth char(20);#添加列\nalter table tableName alter column columnname datatype# 改变数据类型\n\n#drop\ndrop table user index role ......;#drop一般删除数据结构或对象（包括属性列）\t\t，\n#而delete则倾向于删除对象中的元组。\n```\n\n\n\n4、视图\n\n```sql\n#创建\ncreate view S_BJ_VIEW as \nselect * from S where city = '北京' with check option;\n\n#删除\ndrop view ViewName;\n\n#查询\nselect Sno,Sname from S_BJ_VIEW where STAT \u003e 'B';\nselect * from S_AVGQTY where QAVG \u003e=300;\n\n#视图消解法：\n#定义的视图：\ncreate view S_AVGQTY(SNO,PNO,QAVG)\nas select SNO,PNO,AVG(QTY) from SPJ group by SNO,PNO;\n#查询语句：select * from S_AVGQTY where QAVG \u003e=300;\nselect * from S_AVGQTY where QAVG \u003e=300;\n#转换后：\nselect SNO,PNO,AVG(QTY) from SPJ group by SNO,PNO having AVG(QTY)\u003e=300;\n\n#更新数据：\ninsert into S_BJ_VIEW value('S7','北京114514电子厂','B','北京');\n\n#删除：\ndelete from S_BJ_VIEW where SNAME = '北京114514电子厂';\n```\n\n5、安全性\n\n```sql\n#创建用户\ncreate user userName for login loginName with default_schema = schName;\ncreate login loginName with password = ..., default_database = DB_NAME;\n\n#创建角色\ncreate role RoleName; \ngrant RoleName to UserName with admin option;\n\n#权限管理\ngrant all privileges on S to Rolename/Username; #with grant option:可以传递权限\nrevoke all privileges on S from Rolename/Username;\ndeny update on S to Rolename/Username;#拒绝这一权限，使其加入其他有update权限组后仍然不能执行该操作。\n```\n\n6、完整性：\n\n```sql\n#主码定义：\ncreate table s(\n    Sno char(4) primary key;\n    ......\n)\n\ncreate table s(\n    ......\n    primary key (Sno);\n)\ncreate table s (\n\t......\n    primary key(Sno,Pno,Jno);\n)\n\n#参照完整性：\ncreate table s(\n\t......\n    foreign key (SNO) references s(SNO);\n)\n\n#其他完整性：\nnot null #非空\nunique # 唯一\ndefault 'defaultValue' #默认值\n\n#check约束\ncreate table s(\n\t......\n    STAT Char(2) check(STAT in ('A','B','C')),\n    ......\n)\n\n#constraint命令\ncreate table s (\n\t......\n    Sname char(20) constraint c1 not null # 此时c1这一完整性约束(constraint)的值为not null\n)\nalter table s drop constraint c1;\nalter table s add constraint c2 check(......);\n\n```\n\n# 数据库概念复习\n\n## 关系运算\n\n1、选择\n\n$$\\sigma(R)_F=\\{t|t \\in R\\wedge F(t) = true\\}$$\n\n2、投影\n\n$$\\Pi_A(R)=\\{t[A]|t \\in R\\}$$\n\n3、连接\n\n等值连接：选取笛卡尔级中等值的那些元组\n\n自然连接：在等值连接的基础上去掉重复的属性列\n\n4、除运算\n\nR÷S:\n\n用于选出以下内容：\n\n属性：在R不在S的属性\n\n元组：删去的属性对得上在R中的值\n\n比如：\n\nR:\n\nSno Jno\n\na      1\n\nb      2\n\nc      3\n\nS:\n\n1\n\n3\n\nR÷S:\n\nSno\n\na\n\nc\n\n**其他较为重要的运算：交并减、笛卡尔积**\n\n## 数据库安全\n\n### 自主：\n\n授予权限的类型：\n\n| 基本表、视图                                          | 属性列                                         |\n| ----------------------------------------------------- | ---------------------------------------------- |\n| select insert update delete references all privileges | select insert update references all privileges |\n\n一个简单的例子：\n\ngrant update(Sno),select on table SC to User1;\n\n对属性列：权限后面加括号，表明该权限生效的属性列\n\n可传递：with grant option;\n\n收回权限：同grant，但有需要注意的地方：\n\n最后加 cascade/restrict：是否级联操作或约束操作。\n\n角色：\n\n创建：create role rolename ;\n\n授予权限同用户\n\n将角色权限授予用户：grant Rolename to User;\n\n解除权限：revoke Rolename from User;\n\n撤销授权同用户\n\n### 强制：\n\n设定若干级别：\n\nTS\u003e=S\u003e=C\u003e=P\n\n访问规则：\n\n主体许可证等级大于等于客体，可以读。\n\n主体许可证等级小于等于客体，可以写。\n\n第二条解释：高许可证主体没有办法写出一个更低等级的客体。\n\n视图：\n\ncreate view as(select......);\n\ngrant select on view to ......;\n\n## 完整性：\n\n实体完整性：\n\n```sql\ncreate table ...(\n    ......\n    Sname char(20) primary key;#在列级\n    \n    ......\n    primary key (Sname);#在表级\n    \n    primary key (Sname,Sno);#在表级，多列\n\n)\n```\n\n参照完整性：\n\n```sql\ncreate table S2(\n    ......\n    foreign key (Sno) references S(Sno)#表级定义参照完整性\n    on delete cascade on update cascade,#级联删除、更新\n)\n```\n\n约束语句：\n\n```sql\ncreate table R1(\n    Sno char(20) not null,#非空\n    ...... unique,#列值唯一\n    ......check( ......in(......集合))\n    \n    check (Ssex = 'female'or Sname not like 'Ms.%');\n    \n    \n    #constraint\n    Sno char(20) constraint C1 check(......);#形成一个名为C1的约束条件\n    \n    ......\n    constraint C2 check(......)#在表级定义约束条件\n)\n\nalter table R1 drop constraint C1;#删除约束条件\nalter table R1 create constraint c3 check(......);#创建约束条件，表级。\n```\n\n### 断言\n\n在操作时，使断言不为真的操作拒绝执行。\n\n创建断言：\n\n```sql\ncreate assertion assertion_name check (......);\n\ncreate assertion A1 check(60\u003e=select count(*) from SC where C = 'Cource1');\ncreate assertion A2 check(60\u003e=all(select count(*) from SC group by ...));\n```\n\n### 触发器：\n\n触发器用于在某条件由于操作成立时触发其他操作。\n\n```sql\ncreate trigger trigger_name before/after update on SC\nreferencing new/old row as variable#触发器内设变量：原值和新值\nfor each row / statement#每行触发还是每条语句触发\nwhen(......)#触发条件，比如new.grade\u003e=old.grade\ninsert into Table_name(......) values (......)\n\ndrop trigger trigger_name;#删除（删除对象用drop）\n```\n\n## 规范化\n\n1NF：不可分割\n\n2NF：属性由一码确定\n\n3NF：没有不完全函数依赖，没有传递函数依赖\n\nBCNF：每个决定因素都有码\n\n4NF：不存在非平凡、非函数依赖的多值依赖\n\n规范化的实质：概念的单一化\n\n## 数据库设计\n\n### E-R图\n\n联系：菱形，两侧写是1-1、1-n还是n-1的依赖。\n\n属性：圆形，属性不能有属性（不可再分）\n\n实体：矩形\n\n### 实体描述：\n\n实体{实体的主码（下划线），属性1，属性2，属性3}\n\n## 数据库的故障恢复、数据库的并发控制：\n\n### 事务\n\n事务：一个数据库操作序列，具有ACID特性，即原子性、一致性、隔离性、持续性（永久性）\n\n### 数据库的日志文件\n\n日志文件记录：\n\n事务标识、操作类型、操作对象、操作前值、操作后值。\n\n### 故障处理\n\n事务故障：反向扫描日志文件，撤销已经完成的操作\n\n系统故障：视事务完成情况选择是撤销还是重做，撤销：根据日志写更新前值；重做：根据日志写更新后值。\n\n介质故障：从恢复介质重装数据，然后重做已经完成的事务。\n\n### 并发控制\n\n#### 封锁\n\nX锁（写锁）：上X锁后，其他事务不能读写。\n\nS锁（读锁）：上S锁后，其他事务可以再上S锁，可以读，但是不能写。\n\n##### 封锁协议\n\n一级封锁协议：事务在修改数据前必须加X锁，直至事务结束释放。\n\n二级封锁协议：在一级的基础上，事务读要上S锁，读完释放。\n\n三级封锁协议：在一级的基础上，事务读要上S锁，且事务结束时才释放（解决了不可重复读问题）。\n\n### 活锁与死锁\n\n活锁：事务由于等待其他事务结束无法完成（解决：先来先服务）。\n\n死锁：事务间循环等待导致数个事务不能结束（解决：采取措施避免或每隔一段时间诊断死锁并清除）。\n\n### 意向锁（Intention Lock）\n\nIS锁：对一个对象加IS锁，意味着拟对其后裔结点加S锁。如果要对某个元组加S锁，必须先给关系加IS锁。\n\nIX锁：类似IS锁\n\nSIX锁：对这个对象加S锁，然后加IX锁，代表这个事务希望读这个对象，并可能更新个别元组。\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-7-1-sql.markdown"},"buildId":"MkjpXAVhBc5OxoeFL-xod","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>