<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b3c538488f2d96e9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b3c538488f2d96e9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4e2963aac1d75bf2.js" defer=""></script><script src="/_next/static/64aZP254HBesmUVGKxvDO/_buildManifest.js" defer=""></script><script src="/_next/static/64aZP254HBesmUVGKxvDO/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">C Programing Language</div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="markdown-body post_md__a6C1y"><blockquote>
<p>This is a note about The C programing language .</p>
<p>I&#x27;m refactoring this note into English, too.</p>
</blockquote>
<h2>C Basic Knowledge</h2>
<h4>C variable , data types</h4>
<p>C语言中存在已经定义好的数种数据类型,每种数据类型都有其可表示值的范围.</p>
<p><em>接下来要背书了,学个计算机有时候就是和学高中语文一样难受.</em></p>
<p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">存储大小</th><th style="text-align:left">值范围</th></tr></thead><tbody><tr><td style="text-align:left">char</td><td style="text-align:left">1 字节</td><td style="text-align:left">-128 到 127 或 0 到 255</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">1 字节</td><td style="text-align:left">0 到 255</td></tr><tr><td style="text-align:left">signed char</td><td style="text-align:left">1 字节</td><td style="text-align:left">-128 到 127</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">2 或 4 字节</td><td style="text-align:left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 <code>依环境而定</code></td></tr><tr><td style="text-align:left">unsigned int</td><td style="text-align:left">2 或 4 字节</td><td style="text-align:left">0 到 65,535 或 0 到 4,294,967,295 <code>依环境而定</code></td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">2 字节</td><td style="text-align:left">-32,768 到 32,767</td></tr><tr><td style="text-align:left">unsigned short</td><td style="text-align:left">2 字节</td><td style="text-align:left">0 到 65,535</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">4 字节</td><td style="text-align:left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td style="text-align:left">unsigned long</td><td style="text-align:left">4 字节</td><td style="text-align:left">0 到 4,294,967,295</td></tr></tbody></table>
<p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">存储大小</th><th style="text-align:left">值范围</th><th style="text-align:left">精度</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">4 字节</td><td style="text-align:left">1.2E-38 到 3.4E+38</td><td style="text-align:left">6 位小数</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">8 字节</td><td style="text-align:left">2.3E-308 到 1.7E+308</td><td style="text-align:left">15 位小数</td></tr><tr><td style="text-align:left">long double</td><td style="text-align:left">16 字节</td><td style="text-align:left">3.4E-4932 到 1.1E+4932</td><td style="text-align:left">19 位小数</td></tr></tbody></table>
<h4>Functions of Input and Output</h4>
<h4>scanf</h4>
<p>scanf是格式化输入的函数,可以将用户从键盘输入的内容写到一个地址中去.scanf的使用格式是这样的:</p>
<p>scanf(&quot;%d&quot;,&amp;a);</p>
<p>%d代表输入的是一个整型变量,相类似的还有%f(浮点型变量),%lf(长浮点型变量),%c(字符型变量),%s(字符串).</p>
<h3>File R/W</h3>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int main()
{
    //fopen
    FILE *p = fopen(&quot;filename&quot;,&quot;r&quot;);
    char str[100] = {0};
    fscanf(p,&quot;%s&quot;,str);
    
    //freopen
    freopen(&quot;filename&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%s&quot;,str);
}
</code></pre>
<h3>Preprocessing command</h3>
<p>Preprocessing command normally be placed before the start of function definition. It is used to process something before compile .</p>
<h4>Macro definition</h4>
<p>Macro definition normally starts with # , such as:</p>
<pre><code class="language-c">#define
#include
</code></pre>
<p>The rules of using macro definition:</p>
<pre><code class="language-c">#define PI 3.1415926//不含参数的构造,语句结束不需要分号,#include亦然
//编译器会直接将所有的PI替换为3.1415926
#define R 3.0
#define L 2*PI*R
//以上的两行也是可以的,宏定义会展开.
printf(&quot;L&quot;);//格式控制输出时不置反

#define S(a,b) a*b//含参构造,遇到S(数字,数字),替换为a*b
</code></pre>
<p>宏名一般使用大写字母表示,这是一种约定俗成的规则.</p>
<p>宏定义不会为标识符分配内存空间</p>
<p>宏定义的终止:</p>
<pre><code class="language-c">#undefine PI
</code></pre>
<h4>File includes</h4>
<pre><code class="language-c">#include&lt;file name&gt;
#include&quot;file name&quot;//偏向于用户自定义部分
</code></pre>
<h4>Conditional Compile</h4>
<pre><code class="language-c">#ifdef //flag
#define LETTER 1

#if LETTER
//code
#else
//code
</code></pre>
<h3>Pointer</h3>
<p>Pointer is a sort of variable that storages address.</p>
<p>Here are some basic operations of using pointer.</p>
<pre><code class="language-c">int a=3;
int *ptr = &amp;a;//ptr is a variable that points to the address of a
*ptr;//use * to access the data at the address which ptr points to.
*(ptr++);//returns *ptr,and then ptr++
</code></pre>
<h4><strong>Use pointer to access array:</strong></h4>
<pre><code class="language-c">int a[]={1,2,3,5,2,6,2,5}
int *ptr = &amp;a;//the address of an array is just same as the address of the first element of the array.
printf(&quot;%d&quot;,*ptr++); //the ptr++ refers the pointer is going to point to the next element of the array
</code></pre>
<p>Use pointer to access multi dimension array;</p>
<table><thead><tr><th>Array</th><th>Use variable</th><th>Use pointer</th><th>Use pointer</th><th>Use pointer</th></tr></thead><tbody><tr><td>a[i]</td><td>a[i]</td><td>*(a+1)</td><td>*(a+1)</td><td>*(a+i)</td></tr><tr><td>a[i][j]</td><td>a[i][j]</td><td>*(*(a+i)+j)</td><td>*(a[i]+j)</td><td>*(&amp;a[i][0]+j)</td></tr></tbody></table>
<p>An address like <strong>a</strong> (the array is a[3][3]) can&#x27;t be a value of int *p;</p>
<p>So,how to do that?</p>
<p>Use int (*p)[4] , a pointer of this type can have a value like a (the array is a[2][4]).</p>
<h4>Pointer Array</h4>
<pre><code class="language-c">int *p[4];//a define of a pointer array
char *p[4]={&quot;Brazil&quot;,&quot;Russia&quot;,&quot;India&quot;,&quot;China&quot;};//a array of pointer,each points to a string.
</code></pre>
<p>*<em>Sort a char <em>p[]</em></em></p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
    char *p[]={&quot;Aa&quot;,&quot;Bb&quot;,&quot;Cc&quot;,&quot;Dd&quot;};
    for(int i=0;i&lt;4;i++)
    {
        int pos =i;
        char max = *p[i];
        for(int j=i;j&lt;4;j++)
        {
            if(*p[j]&gt;max)
            {
                max=*p[j];
                pos=j;
            }
        }
        char* t= p[i];
        p[i]=p[pos];
        p[pos]=t;
    }

    
    return 0;
}
</code></pre>
<h4>Dynamic Memory Space</h4>
<pre><code class="language-c">int *p = (int*)malloc(4);; //set a space whose size is 4.
int *p[4] = (int*)calloc(n,sizeof(int));//set n*size array.
realloc(p,8);//resize.
free(p);//delete.
</code></pre>
<h4>Pointer to Pointer</h4>
<pre><code class="language-c">int **p;
**p=2;
*p;//an address
**p;//a value
</code></pre>
<h4>Parameters to main</h4>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main(int argc,char* argv[])//argc refers string numbers and argv refers string that put in.
    //argv[0]=your program name
{
    for(int i=1;argv[i]!=NULL;i++)
    printf(&quot;%s\n&quot;,argv[i]);

    
    return 0;
}
</code></pre>
<h3>Dynamic Memory space</h3>
<p>Malloc</p>
<pre><code class="language-c">int main()
{
    struct Student *head;
    head = (struct Student *)malloc(sizeof(struct Student));
}
</code></pre>
<p>Calloc</p>
<pre><code class="language-c">int main()
{
    head = (struct Student*)calloc(100,sizeof(struct Student))
}
</code></pre>
<p>Realloc</p>
<pre><code class="language-c">int main()
{
    realloc(*p,size);
}
</code></pre>
<p>Free</p>
<pre><code class="language-c">int main()
{
    free(*p);
}
</code></pre>
<p>Example:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct Student 
{
    int age=0;
    struct Student *next=NULL;
};

int main()
{
    struct Student *head,*current;
    int i=0;
    head = (struct Student*)malloc(sizeof(struct Student));
    current=head;
    while(i==0)
    {
        printf(&quot;Add student? 0/yes 1/no\n&quot;);
        scanf(&quot;%d&quot;,&amp;i);
        if(i==0)
        {
            printf(&quot;input age\n&quot;);
            scanf(&quot;%d&quot;,&amp;(*current).age);
            (*current).next=(struct Student*)malloc(sizeof(struct Student));
            current = (*current).next;
        }else
        {
            (*current).age=0;
            (*current).next=NULL;
        }
        
    }
    return 0;
}
</code></pre>
<h2>File operation</h2>
<h4>File pointer</h4>
<pre><code class="language-c">FILE *fp;//create a pointer point to the head of the file.
fp = fopen(&quot;file.txt&quot;,&quot;a+&quot;);//open the file.
fclose(fp);
</code></pre>
<h4>File functions</h4>
<pre><code class="language-c">//freopen
freopen(&quot;File&quot;,&quot;a+&quot;,stdin);
freopen(&quot;File&quot;,&quot;w&quot;,stdout);
fclose(ptr);//or the file will not be write.

fgetc(fp);
fputc(ch,fp);
//read and write character in a file.

fgets(str,n,fp);//See carefully, there&#x27;s n in parameter list, n refers the string&#x27;s length is n-1 .
fputs(str,fp);

fscanf(fp,&quot;Format&quot;,parameter list);
fprintf(fp,&quot;Format&quot;,parameter list);

//read and write in bit
fread(buffer,size,count,fp);
fwrite(buffer,size,count,fp);

//examples:
fread(&amp;stu_list[i],sizeof(struct student),1,fp);
fwrite(&amp;stu_list[i],sizeof(struct student),1,fp);//you can see it as using disk as memory.

</code></pre>
<h4>Radom R/W files</h4>
<pre><code class="language-c">rewind(fp);//move the file flag back to the head.
fseek(fp,100L,0);//move the flag to the position 100 byte away from the head.
fseek(fp,100L,1);//move foward 100 byte from current position
fseek(fp,-50L,3);//move back 50 byte from the end.
</code></pre>
<table><thead><tr><th>start position</th><th>name</th><th>number reference</th></tr></thead><tbody><tr><td>head</td><td>SEEK_SET</td><td>0</td></tr><tr><td>current position</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>end</td><td>SEEK_END</td><td>2</td></tr></tbody></table></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"C Programing Language\"\nintro:   \"\"\ndate:       2019-11-12 10:13:00\nauthor:     \"Makinohara\"\nfeatured_image: http://msfasr.com/img/post-bg-css.jpg\ncatalog: true\ntags:\n    - 编程语言\n---\n\n\u003e This is a note about The C programing language .\n\u003e\n\u003e I'm refactoring this note into English, too. \n\n## C Basic Knowledge\n\n#### C variable , data types\n\nC语言中存在已经定义好的数种数据类型,每种数据类型都有其可表示值的范围.\n\n*接下来要背书了,学个计算机有时候就是和学高中语文一样难受.*\n\n下表列出了关于标准整数类型的存储大小和值范围的细节：\n\n| 类型           | 存储大小    | 值范围                                                       |\n| :------------- | :---------- | :----------------------------------------------------------- |\n| char           | 1 字节      | -128 到 127 或 0 到 255                                      |\n| unsigned char  | 1 字节      | 0 到 255                                                     |\n| signed char    | 1 字节      | -128 到 127                                                  |\n| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 `依环境而定` |\n| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295 `依环境而定`               |\n| short          | 2 字节      | -32,768 到 32,767                                            |\n| unsigned short | 2 字节      | 0 到 65,535                                                  |\n| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                              |\n| unsigned long  | 4 字节      | 0 到 4,294,967,295                                           |\n\n下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：\n\n| 类型        | 存储大小 | 值范围                 | 精度      |\n| :---------- | :------- | :--------------------- | :-------- |\n| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |\n| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |\n| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |\n\n\n\n#### Functions of Input and Output\n\n#### scanf\n\nscanf是格式化输入的函数,可以将用户从键盘输入的内容写到一个地址中去.scanf的使用格式是这样的:\n\nscanf(\"%d\",\u0026a);\n\n%d代表输入的是一个整型变量,相类似的还有%f(浮点型变量),%lf(长浮点型变量),%c(字符型变量),%s(字符串).\n\n### File R/W\n\n```c\n#include\u003cstdio.h\u003e\nint main()\n{\n    //fopen\n    FILE *p = fopen(\"filename\",\"r\");\n    char str[100] = {0};\n    fscanf(p,\"%s\",str);\n    \n    //freopen\n    freopen(\"filename\",\"r\",stdin);\n    scanf(\"%s\",str);\n}\n```\n\n\n\n### Preprocessing command\n\nPreprocessing command normally be placed before the start of function definition. It is used to process something before compile .\n\n#### Macro definition\n\nMacro definition normally starts with # , such as:\n\n```c\n#define\n#include\n```\n\nThe rules of using macro definition:\n\n```c\n#define PI 3.1415926//不含参数的构造,语句结束不需要分号,#include亦然\n//编译器会直接将所有的PI替换为3.1415926\n#define R 3.0\n#define L 2*PI*R\n//以上的两行也是可以的,宏定义会展开.\nprintf(\"L\");//格式控制输出时不置反\n\n#define S(a,b) a*b//含参构造,遇到S(数字,数字),替换为a*b\n```\n\n宏名一般使用大写字母表示,这是一种约定俗成的规则.\n\n宏定义不会为标识符分配内存空间\n\n宏定义的终止:\n\n```c\n#undefine PI\n```\n\n#### File includes\n\n```c\n#include\u003cfile name\u003e\n#include\"file name\"//偏向于用户自定义部分\n```\n\n#### Conditional Compile\n\n```c\n#ifdef //flag\n#define LETTER 1\n\n#if LETTER\n//code\n#else\n//code\n```\n\n### Pointer\n\nPointer is a sort of variable that storages address.\n\nHere are some basic operations of using pointer.\n\n```c\nint a=3;\nint *ptr = \u0026a;//ptr is a variable that points to the address of a\n*ptr;//use * to access the data at the address which ptr points to.\n*(ptr++);//returns *ptr,and then ptr++\n```\n\n#### **Use pointer to access array:**\n\n```c\nint a[]={1,2,3,5,2,6,2,5}\nint *ptr = \u0026a;//the address of an array is just same as the address of the first element of the array.\nprintf(\"%d\",*ptr++); //the ptr++ refers the pointer is going to point to the next element of the array\n```\n\nUse pointer to access multi dimension array;\n\n| Array    | Use variable | Use pointer  | Use pointer | Use pointer     |\n| -------- | ------------ | ------------ | ----------- | --------------- |\n| a[i]     | a[i]         | *(a+1)       | *(a+1)      | *(a+i)          |\n| a\\[i][j] | a\\[i][j]     | *(\\*(a+i)+j) | *(a[i]+j)   | *(\\\u0026a\\[i][0]+j) |\n\nAn address like **a** (the array is a\\[3][3]) can't be a value of int *p;\n\nSo,how to do that?\n\nUse int (*p)[4] , a pointer of this type can have a value like a (the array is a\\[2][4]).\n\n#### Pointer Array\n\n```c\nint *p[4];//a define of a pointer array\nchar *p[4]={\"Brazil\",\"Russia\",\"India\",\"China\"};//a array of pointer,each points to a string.\n```\n\n**Sort a char *p[]**\n\n```c\n#include\u003cstdio.h\u003e\n#include\u003cstring.h\u003e\n#include\u003cstdlib.h\u003e\nint main()\n{\n    char *p[]={\"Aa\",\"Bb\",\"Cc\",\"Dd\"};\n    for(int i=0;i\u003c4;i++)\n    {\n        int pos =i;\n        char max = *p[i];\n        for(int j=i;j\u003c4;j++)\n        {\n            if(*p[j]\u003emax)\n            {\n                max=*p[j];\n                pos=j;\n            }\n        }\n        char* t= p[i];\n        p[i]=p[pos];\n        p[pos]=t;\n    }\n\n    \n    return 0;\n}\n```\n\n\n\n#### Dynamic Memory Space\n\n```c\nint *p = (int*)malloc(4);; //set a space whose size is 4.\nint *p[4] = (int*)calloc(n,sizeof(int));//set n*size array.\nrealloc(p,8);//resize.\nfree(p);//delete.\n```\n\n#### Pointer to Pointer\n\n```c\nint **p;\n**p=2;\n*p;//an address\n**p;//a value\n```\n\n#### Parameters to main\n\n```c\n#include\u003cstdio.h\u003e\n#include\u003cstring.h\u003e\n#include\u003cstdlib.h\u003e\nint main(int argc,char* argv[])//argc refers string numbers and argv refers string that put in.\n    //argv[0]=your program name\n{\n    for(int i=1;argv[i]!=NULL;i++)\n    printf(\"%s\\n\",argv[i]);\n\n    \n    return 0;\n}\n```\n\n### Dynamic Memory space\n\nMalloc\n\n```c\nint main()\n{\n    struct Student *head;\n    head = (struct Student *)malloc(sizeof(struct Student));\n}\n```\n\nCalloc\n\n```c\nint main()\n{\n    head = (struct Student*)calloc(100,sizeof(struct Student))\n}\n```\n\nRealloc\n\n```c\nint main()\n{\n    realloc(*p,size);\n}\n```\n\nFree\n\n```c\nint main()\n{\n    free(*p);\n}\n```\n\nExample:\n\n```c\n#include\u003cstdio.h\u003e\n#include\u003cstdlib.h\u003e\n\nstruct Student \n{\n    int age=0;\n    struct Student *next=NULL;\n};\n\nint main()\n{\n    struct Student *head,*current;\n    int i=0;\n    head = (struct Student*)malloc(sizeof(struct Student));\n    current=head;\n    while(i==0)\n    {\n        printf(\"Add student? 0/yes 1/no\\n\");\n        scanf(\"%d\",\u0026i);\n        if(i==0)\n        {\n            printf(\"input age\\n\");\n            scanf(\"%d\",\u0026(*current).age);\n            (*current).next=(struct Student*)malloc(sizeof(struct Student));\n            current = (*current).next;\n        }else\n        {\n            (*current).age=0;\n            (*current).next=NULL;\n        }\n        \n    }\n    return 0;\n}\n```\n\n## File operation\n\n#### File pointer\n\n```c\nFILE *fp;//create a pointer point to the head of the file.\nfp = fopen(\"file.txt\",\"a+\");//open the file.\nfclose(fp);\n```\n\n#### File functions\n\n```c\n//freopen\nfreopen(\"File\",\"a+\",stdin);\nfreopen(\"File\",\"w\",stdout);\nfclose(ptr);//or the file will not be write.\n\nfgetc(fp);\nfputc(ch,fp);\n//read and write character in a file.\n\nfgets(str,n,fp);//See carefully, there's n in parameter list, n refers the string's length is n-1 .\nfputs(str,fp);\n\nfscanf(fp,\"Format\",parameter list);\nfprintf(fp,\"Format\",parameter list);\n\n//read and write in bit\nfread(buffer,size,count,fp);\nfwrite(buffer,size,count,fp);\n\n//examples:\nfread(\u0026stu_list[i],sizeof(struct student),1,fp);\nfwrite(\u0026stu_list[i],sizeof(struct student),1,fp);//you can see it as using disk as memory.\n\n```\n\n#### Radom R/W files\n\n```c\nrewind(fp);//move the file flag back to the head.\nfseek(fp,100L,0);//move the flag to the position 100 byte away from the head.\nfseek(fp,100L,1);//move foward 100 byte from current position\nfseek(fp,-50L,3);//move back 50 byte from the end.\n```\n\n| start position   | name     | number reference |\n| ---------------- | -------- | ---------------- |\n| head             | SEEK_SET | 0                |\n| current position | SEEK_CUR | 1                |\n| end              | SEEK_END | 2                |\n\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2019-11-12-C.md"},"buildId":"64aZP254HBesmUVGKxvDO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>