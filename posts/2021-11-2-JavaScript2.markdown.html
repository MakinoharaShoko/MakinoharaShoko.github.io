<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b3c538488f2d96e9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b3c538488f2d96e9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a12bab8c2b2a611d.js" defer=""></script><script src="/_next/static/edEkolaI9vomiF4NWLiqs/_buildManifest.js" defer=""></script><script src="/_next/static/edEkolaI9vomiF4NWLiqs/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">JavaScript高级程序设计</div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="markdown-body post_md__a6C1y"><blockquote>
<p>为系统学习 JavaScript ，重写有关 JavaScript 的笔记，使用教材《JavaScript高级程序设计》第四版。</p>
</blockquote>
<h1>新笔记：直接使用代码描述笔记</h1>
<p>注意：因此本博文不再更新</p>
<p><a href="https://github.com/MakinoharaShoko/Learning-Code/tree/main/JS">https://github.com/MakinoharaShoko/Learning-Code/tree/main/JS</a></p>
<h1>基础概念</h1>
<h2>1、DOM &amp; BOM</h2>
<p>DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API， 可以轻松地删除、添加、替换、修改节点。</p>
<p>总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的 扩展都归在BOM的范畴内。比如，下面就是这样一些扩展：</p>
<p> 弹出新浏览器窗口的能力；</p>
<p> 移动、缩放和关闭浏览器窗口的能力；</p>
<p> navigator 对象，提供关于浏览器的详尽信息；
 location 对象，提供浏览器加载页面的详尽信息；</p>
<p> screen 对象，提供关于用户屏幕分辨率的详尽信息；</p>
<p> performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；</p>
<p> 对 cookie的支持；
 其他自定义对象，如 XMLHttpRequest 和 IE的 ActiveXObject。</p>
<h2>2、加载方式</h2>
<h3>1、行内</h3>
<pre><code>&lt;script&gt; 
function sayHi() { 
	console.log(&quot;Hi!&quot;);
}
&lt;/script&gt;
</code></pre>
<h3>2、外部文件</h3>
<pre><code>&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3>3、加载位置</h3>
<p>推荐加载在 body 内容的最后，这样就会在渲染界面后加载JavaScript</p>
<pre><code>&lt;!DOCTYPE html&gt; 
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Example HTML Page&lt;/title&gt; 
	&lt;/head&gt; 
	&lt;body&gt; 
	&lt;!-- 这里是页面内容 --&gt;
	&lt;script src=&quot;example1.js&quot;&gt;&lt;/script&gt; 
	&lt;script src=&quot;example2.js&quot;&gt;&lt;/script&gt; 
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>推迟到解析到结束标签 &lt;/html&gt; 执行（只对外部脚本文件才有效）：</p>
<pre><code>&lt;script defer src=&quot;example1.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h1>语言基础</h1>
<h3>变量声明提升</h3>
<p>var 提升，let不提升</p>
<pre><code>console.log(name);//undefined
var name = &#x27;Matt&#x27;;

console.log(age);//ReferenceError,暂时性死区
let age = 26;
</code></pre>
<p>let：声明范围是块作用域，所以不会造成循环定义的迭代变量渗透到外部。</p>
<p>const声明：限制不能修改其值或引用的对象，但是可以修改该对象的内部属性。</p>
<p><strong>尽可能使用let、const，避免使用var，const优先</strong></p>
<h3>变量类型</h3>
<pre><code>Undefined
Null//typeof Null ===&#x27;object&#x27;
Boolean
Number
String
Symbol
(Object)
</code></pre>
<p>undefined 是一个特殊值，在if判断为假</p>
<p>null：可以看做是空对象指针</p>
<h3>数值</h3>
<p>特殊：NaN:not a number</p>
<h4>转换函数：</h4>
<pre><code>Number()
parseInt()
parseFloat()
</code></pre>
<h3>字符串</h3>
<p>字符串的特点：不可变，如果要修改只能销毁原有的字符串。</p>
<p>转换函数：</p>
<pre><code>toString()
String()
String(null) === &#x27;null&#x27;
String(undefined) === &#x27;undefined&#x27;
</code></pre>
<h4>模板字面量</h4>
<p>模板字面量可用于字符串插值：</p>
<pre><code>let value1 = 233;
let value2 = &#x27;sec&#x27;
let str1 = `now is ${value1} ${value2}.`
</code></pre>
<p>模板字面量可以跨行定义字符串</p>
<pre><code>let str2 = `the
Kamome&#x27;s humble abode`
</code></pre>
<p>原始字符串：</p>
<pre><code>String.raw`\u00a9`
</code></pre>
<h3>Symbol</h3>
<p>TODO:写关于symbol的笔记</p>
<h3>Object</h3>
<p>Object 的属性和方法</p>
<pre><code>constructor:创建
hasOwnProperty(propertyName):判断当前对象是否存在给定属性
isPrototypeOf:
propertyIsEnumerable(propertyName):判断给定的属性是否可用
toLocaleString():返回对象的字符串表示（反映本地化执行环境）
toString:返回对象的字符串表示
valueOf():返回对应的字符串
</code></pre>
<h3>算符</h3>
<p>一元算符</p>
<pre><code>//一元运算符
let str1 = &#x27;123&#x27;;
str1 = +str1;
console.log(typeof str1);//number
</code></pre>
<h1>异步编程</h1>
<h2>Promise</h2>
<h3>Promise的基本使用</h3>
<pre><code>let myFirstPromise = new Promise(function(resolve, reject){
    //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)
    //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.
    setTimeout(function(){
        resolve(&quot;成功!&quot;); //代码正常执行！
    }, 250);
});
</code></pre>
<h3>函数返回Promise</h3>
<pre><code>function getUserInfo() {
	//获取个人信息
	return new Promise((resolve, reject) =&gt; {
		dbo.collection(&#x27;users&#x27;).find({ eid: userEID }).toArray((err, result) =&gt; {
			if (err) throw err;
            returnMessage[&#x27;userInfo&#x27;] = result;
            resolve();
        })
    })
}
</code></pre>
<h3>Promise.all的使用</h3>
<pre><code>//执行查询
Promise.all([getUserInfo(), getMessage(), getFriendReq(), getFriendList()]).then(() =&gt; { closeAndSend() })
</code></pre>
<h1>函数</h1>
<h3>函数的几种描述：</h3>
<pre><code>function func1(){
	return 1;
}

let func2 = function(){
	return 1;
}

let func3 = () =&gt; {
	return 1;
}

//立即执行的函数
(()=&gt;1)();
</code></pre>
<p>箭头函数(Lambda)</p>
<pre><code>(param1, param2, …, paramN) =&gt; { statements }
(param1, param2, …, paramN) =&gt; expression
//相当于：(param1, param2, …, paramN) =&gt;{ return expression; }

// 当只有一个参数时，圆括号是可选的：
(singleParam) =&gt; { statements }
singleParam =&gt; { statements }

// 没有参数的函数应该写成一对圆括号。
() =&gt; { statements }
</code></pre></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"JavaScript高级程序设计\"\nintro:   \"\"\ndate:       2021-11-2 08:00:00\nauthor:     \"Makinohara\"\nfeatured_image: http://msfasr.com/img/py.jfif\ncatalog: true\ntags:\n    - 编程语言\n---\n\n\u003e 为系统学习 JavaScript ，重写有关 JavaScript 的笔记，使用教材《JavaScript高级程序设计》第四版。\n\n# 新笔记：直接使用代码描述笔记\n\n注意：因此本博文不再更新\n\nhttps://github.com/MakinoharaShoko/Learning-Code/tree/main/JS\n\n# 基础概念\n\n## 1、DOM \u0026 BOM\n\nDOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API， 可以轻松地删除、添加、替换、修改节点。\n\n总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的 扩展都归在BOM的范畴内。比如，下面就是这样一些扩展：\n\n 弹出新浏览器窗口的能力；\n\n 移动、缩放和关闭浏览器窗口的能力；\n\n navigator 对象，提供关于浏览器的详尽信息；\n location 对象，提供浏览器加载页面的详尽信息；\n\n screen 对象，提供关于用户屏幕分辨率的详尽信息；\n\n performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；\n\n 对 cookie的支持；\n 其他自定义对象，如 XMLHttpRequest 和 IE的 ActiveXObject。\n\n## 2、加载方式\n\n### 1、行内\n\n```\n\u003cscript\u003e \nfunction sayHi() { \n\tconsole.log(\"Hi!\");\n}\n\u003c/script\u003e\n```\n\n### 2、外部文件\n\n```\n\u003cscript src=\"example.js\"\u003e\u003c/script\u003e\n```\n\n### 3、加载位置\n\n推荐加载在 body 内容的最后，这样就会在渲染界面后加载JavaScript\n\n```\n\u003c!DOCTYPE html\u003e \n\u003chtml\u003e\n\t\u003chead\u003e\n\t\t\u003ctitle\u003eExample HTML Page\u003c/title\u003e \n\t\u003c/head\u003e \n\t\u003cbody\u003e \n\t\u003c!-- 这里是页面内容 --\u003e\n\t\u003cscript src=\"example1.js\"\u003e\u003c/script\u003e \n\t\u003cscript src=\"example2.js\"\u003e\u003c/script\u003e \n\t\u003c/body\u003e\n\u003c/html\u003e\n```\n\n推迟到解析到结束标签 \\\u003c/html\u003e 执行（只对外部脚本文件才有效）：\n\n```\n\u003cscript defer src=\"example1.js\"\u003e\u003c/script\u003e\n```\n\n# 语言基础\n\n### 变量声明提升\n\nvar 提升，let不提升\n\n```\nconsole.log(name);//undefined\nvar name = 'Matt';\n\nconsole.log(age);//ReferenceError,暂时性死区\nlet age = 26;\n```\n\nlet：声明范围是块作用域，所以不会造成循环定义的迭代变量渗透到外部。\n\nconst声明：限制不能修改其值或引用的对象，但是可以修改该对象的内部属性。\n\n**尽可能使用let、const，避免使用var，const优先**\n\n### 变量类型\n\n```\nUndefined\nNull//typeof Null ==='object'\nBoolean\nNumber\nString\nSymbol\n(Object)\n```\n\nundefined 是一个特殊值，在if判断为假\n\nnull：可以看做是空对象指针\n\n### 数值\n\n特殊：NaN:not a number\n\n#### 转换函数：\n\n```\nNumber()\nparseInt()\nparseFloat()\n```\n\n### 字符串\n\n字符串的特点：不可变，如果要修改只能销毁原有的字符串。\n\n转换函数：\n\n```\ntoString()\nString()\nString(null) === 'null'\nString(undefined) === 'undefined'\n```\n\n#### 模板字面量\n\n模板字面量可用于字符串插值：\n\n```\nlet value1 = 233;\nlet value2 = 'sec'\nlet str1 = `now is ${value1} ${value2}.`\n```\n\n模板字面量可以跨行定义字符串\n\n```\nlet str2 = `the\nKamome's humble abode`\n```\n\n原始字符串：\n\n```\nString.raw`\\u00a9`\n```\n\n### Symbol\n\nTODO:写关于symbol的笔记\n\n### Object\n\nObject 的属性和方法\n\n```\nconstructor:创建\nhasOwnProperty(propertyName):判断当前对象是否存在给定属性\nisPrototypeOf:\npropertyIsEnumerable(propertyName):判断给定的属性是否可用\ntoLocaleString():返回对象的字符串表示（反映本地化执行环境）\ntoString:返回对象的字符串表示\nvalueOf():返回对应的字符串\n```\n\n### 算符\n\n一元算符\n\n```\n//一元运算符\nlet str1 = '123';\nstr1 = +str1;\nconsole.log(typeof str1);//number\n```\n\n# 异步编程\n\n## Promise\n\n### Promise的基本使用\n\n```\nlet myFirstPromise = new Promise(function(resolve, reject){\n    //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)\n    //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.\n    setTimeout(function(){\n        resolve(\"成功!\"); //代码正常执行！\n    }, 250);\n});\n```\n\n### 函数返回Promise\n\n```\nfunction getUserInfo() {\n\t//获取个人信息\n\treturn new Promise((resolve, reject) =\u003e {\n\t\tdbo.collection('users').find({ eid: userEID }).toArray((err, result) =\u003e {\n\t\t\tif (err) throw err;\n            returnMessage['userInfo'] = result;\n            resolve();\n        })\n    })\n}\n```\n\n### Promise.all的使用\n\n```\n//执行查询\nPromise.all([getUserInfo(), getMessage(), getFriendReq(), getFriendList()]).then(() =\u003e { closeAndSend() })\n```\n\n# 函数\n\n### 函数的几种描述：\n\n```\nfunction func1(){\n\treturn 1;\n}\n\nlet func2 = function(){\n\treturn 1;\n}\n\nlet func3 = () =\u003e {\n\treturn 1;\n}\n\n//立即执行的函数\n(()=\u003e1)();\n```\n\n箭头函数(Lambda)\n\n```\n(param1, param2, …, paramN) =\u003e { statements }\n(param1, param2, …, paramN) =\u003e expression\n//相当于：(param1, param2, …, paramN) =\u003e{ return expression; }\n\n// 当只有一个参数时，圆括号是可选的：\n(singleParam) =\u003e { statements }\nsingleParam =\u003e { statements }\n\n// 没有参数的函数应该写成一对圆括号。\n() =\u003e { statements }\n```\n\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2021-11-2-JavaScript2.markdown"},"buildId":"edEkolaI9vomiF4NWLiqs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>