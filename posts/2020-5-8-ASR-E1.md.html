<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/7835419622e5afa0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7835419622e5afa0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/50425c9106578cba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50425c9106578cba.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd66785574873e8.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c0ab723d8d52e6df.js" defer=""></script><script src="/_next/static/FSHNphORtj5MGrig2uX3c/_buildManifest.js" defer=""></script><script src="/_next/static/FSHNphORtj5MGrig2uX3c/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">KMP算法详解<img alt="open" src="/_next/static/media/down.9feac32f.png" width="480" height="480" decoding="async" data-nimg="1" class="post_iconSmall__5Hxz8" loading="lazy" style="color:transparent"/></div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="post_mdWarpper__Brjcd"><div class="markdown-body post_md__a6C1y"><h2 id="kmp理论概要">KMP理论概要</h2>
<p>KMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。</p>
<p>首先，让我们看看其是如何减少重复的步骤的：</p>
<p>假如有一字符串S：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>c</td><td>a</td><td>a</td><td>b</td><td>a</td></tr></tbody></table>
<p>我们想要让字符串“aaba”与其匹配。</p>
<p>那么，匹配看起来就是这样：</p>
<p>第一次匹配：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td><strong>c</strong></td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>a</td><td>a</td><td>b</td><td><strong>a(不匹配)</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p>此时指针回退，主串指针回退至2，模式串回退至1。</p>
<p>第二次匹配：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td><strong>b</strong></td><td>c</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td></td><td>a</td><td><strong>a（不匹配）</strong></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p>此时主串指针再次回退。</p>
<p>可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。</p>
<p>实际上，第二次匹配可以简化为：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td><strong>c</strong></td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td></td><td></td><td></td><td><strong>a(不匹配)</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p>然后是第三次匹配：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>c</td><td>a</td><td>a</td><td>b</td><td><strong>a</strong></td></tr><tr><td></td><td></td><td></td><td></td><td>a</td><td>a</td><td>b</td><td><strong>a(匹配成功)</strong></td></tr></tbody></table>
<p>那么，如何算出模式串指针应当回退多少呢？</p>
<p>根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。</p>
<p>观察以下两个对应表：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>0</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td></tr></tbody></table>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table>
<p>可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。</p>
<p>原因在于此：</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td><em><strong>a</strong></em></td><td><em><strong>a</strong></em></td><td><em><strong>b</strong></em></td><td>a</td><td><em><strong>a</strong></em></td><td><em><strong>a</strong></em></td><td><em><strong>b</strong></em></td><td>a</td></tr><tr><td>0</td><td>1</td><td>2</td><td>1</td><td>2</td><td>3</td><td>3</td><td>4</td></tr></tbody></table>
<p>可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？</p>
<p>举例说明：</p>
<p>匹配 “aabaaaabcaabaaaba”与“aabaaaba”</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td><strong>c</strong></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>a</td><td>a</td><td>b</td><td>a</td><td><strong>a</strong></td><td><strong>a</strong></td><td><strong>b</strong></td><td><strong>a(不匹配）</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>与5相同</td><td>与6相同</td><td>与7相同</td><td></td><td><strong>匹配</strong></td><td><strong>匹配</strong></td><td><strong>匹配</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td><strong>c</strong></td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td></td><td></td><td></td><td></td><td>a</td><td>a</td><td>b</td><td><strong>a（继续匹配）</strong></td><td>a</td><td>a</td><td>b</td><td>a</td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p>可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。</p>
<p>那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？</p>
<p>综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。</p>
<p>如：aabaaaba</p>
<table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td></tr><tr><td>0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。）</td><td>1（无论有无重复都为1）</td><td>2（重复了a）</td><td>1（没有重复）</td><td>2（重复了a）</td><td>3（重复了aa）</td><td>3（重复了aa）</td><td>4（重复了aab）</td></tr></tbody></table>
<p>由此，推导程序如下：</p>
<pre><code class="language-c++">std::vector&lt;int&gt; getNext(std::string in) {
        std::vector&lt;int&gt; res(in.length() + 1);
        int i = 1, j = 0;
        res[1] = 0;
        while (i &lt; in.length()) {
            if (j == 0 || in[j - 1] == in[i - 1]) {
                i++;
                j++;
                res[i] = j;
            } else
                j = res[j];
        }
        return res;
    }
</code></pre>
<h2 id="kmp再优化">KMP再优化：</h2>
<p>我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？</p>
<p>观察以下字符串：</p></div></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      \"KMP算法详解\"\nintro:      \"\"\ndate:       2020-5-8 11:00:00\nauthor:     \"Makinohara\"\ncatalog: true\ntags:\n    - 计算机基础\n---\n\n## KMP理论概要\n\nKMP字符串匹配算法是一种效率更高的字符串匹配算法。相比于传统算法，由于其主串指针不需要回溯，因此大大减少了匹配需要的时间。\n\n首先，让我们看看其是如何减少重复的步骤的：\n\n假如有一字符串S：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | c    | a    | a    | b    | a    |\n\n我们想要让字符串“aaba”与其匹配。\n\n那么，匹配看起来就是这样：\n\n第一次匹配：\n\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\n| a    | a    | b    | **a(不匹配)** |      |      |      |      |\n\n此时指针回退，主串指针回退至2，模式串回退至1。\n\n第二次匹配：\n\n| 1    | 2    | 3               | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | **b**           | c    | a    | a    | b    | a    |\n|      | a    | **a（不匹配）** |      |      |      |      |      |\n\n此时主串指针再次回退。\n\n可以看出，我们的主串指针在匹配过程中一直在重复读取某一段内容，这是大大有损效率的。若是能使主串指针不回退，只控制模式串指针回退一段距离，这也许可以改善。\n\n实际上，第二次匹配可以简化为：\n\n| 1    | 2    | 3    | 4             | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ------------- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | **c**         | a    | a    | b    | a    |\n|      |      |      | **a(不匹配)** |      |      |      |      |\n\n然后是第三次匹配：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8               |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |\n| a    | a    | b    | c    | a    | a    | b    | **a**           |\n|      |      |      |      | a    | a    | b    | **a(匹配成功)** |\n\n那么，如何算出模式串指针应当回退多少呢？\n\n根据KMP算法的核心思想，模式串T拥有一个对应表，用于记录模式串T重复的部分。\n\n观察以下两个对应表：\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | a    | a    | a    | b    | a    |\n| 0    | 1    | 2    | 1    | 2    | 3    | 3    | 4    |\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | b    | c    | d    | e    | f    | g    | h    |\n| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |\n\n可以看出，1号表格中，在匹配到第8个位置时，若是不匹配，只需要回到4对应的位置继续匹配就可以了，但是2号表格中，每一次匹配都必须要回到位置1重新匹配。\n\n\n\n原因在于此：\n\n| 1       | 2       | 3       | 4    | 5       | 6       | 7       | 8    |\n| ------- | ------- | ------- | ---- | ------- | ------- | ------- | ---- |\n| ***a*** | ***a*** | ***b*** | a    | ***a*** | ***a*** | ***b*** | a    |\n| 0       | 1       | 2       | 1    | 2       | 3       | 3       | 4    |\n\n可以看到，若是第8个字符不匹配并不影响前3个字符已经匹配成功的事实。因为5、6、7三个字符与1、2、3无异。既然我们已经匹配过a、b、c三个字符了，何必再匹配一次？\n\n举例说明：\n\n匹配 “aabaaaabcaabaaaba”与“aabaaaba”\n\n| 1       | 2       | 3       | 4    | 5        | 6        | 7        | 8              | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\n| ------- | ------- | ------- | ---- | -------- | -------- | -------- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a       | a       | b       | a    | a        | a        | b        | **c**          | a    | a    | b    | a    | a    | a    | b    | a    |\n| a       | a       | b       | a    | **a**    | **a**    | **b**    | **a(不匹配）** |      |      |      |      |      |      |      |      |\n| 与5相同 | 与6相同 | 与7相同 |      | **匹配** | **匹配** | **匹配** |                |      |      |      |      |      |      |      |      |\n\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8                 | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a    | a    | b    | a    | a    | a    | b    | **c**             | a    | a    | b    | a    | a    | a    | b    | a    |\n|      |      |      |      | a    | a    | b    | **a（继续匹配）** | a    | a    | b    | a    |      |      |      |      |\n\n可以看到，由于我们已经在匹配5、6、7三个字符时确定a、a、b三个字符是匹配的，那么我们就不需要在匹配前三个字符上浪费时间了。\n\n那么，我们已经知道了如何使用模式串的“特性数组”来减少匹配重复字符上的浪费，但是这个数组怎样计算出来呢？\n\n综合来看，我们计算此数组的目的就在于减少重复匹配，那么此数组的最大目的就是找出在制定字母之前有多少重复部分。\n\n如：aabaaaba\n\n| 1                                                            | 2                      | 3            | 4             | 5            | 6             | 7             | 8              |\n| ------------------------------------------------------------ | ---------------------- | ------------ | ------------- | ------------ | ------------- | ------------- | -------------- |\n| a                                                            | a                      | b            | a             | a            | a             | b             | a              |\n| 0（因为每次匹配都是先使指针+1再匹配，若是第一个字符就不匹配，那么就使指针位置为0，匹配时从第一个开始匹配。） | 1（无论有无重复都为1） | 2（重复了a） | 1（没有重复） | 2（重复了a） | 3（重复了aa） | 3（重复了aa） | 4（重复了aab） |\n\n由此，推导程序如下：\n\n```c++\nstd::vector\u003cint\u003e getNext(std::string in) {\n        std::vector\u003cint\u003e res(in.length() + 1);\n        int i = 1, j = 0;\n        res[1] = 0;\n        while (i \u003c in.length()) {\n            if (j == 0 || in[j - 1] == in[i - 1]) {\n                i++;\n                j++;\n                res[i] = j;\n            } else\n                j = res[j];\n        }\n        return res;\n    }\n```\n\n## KMP再优化：\n\n我们已经看出KMP算法是如何减少重复匹配来减少匹配时间的。但是，是否有一种更优化的方法呢？\n\n观察以下字符串：\n\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2020-5-8-ASR-E1.md"},"buildId":"FSHNphORtj5MGrig2uX3c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>