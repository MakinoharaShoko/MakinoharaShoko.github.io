<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/cfd688f8087f37ee.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cfd688f8087f37ee.css" data-n-g=""/><link rel="preload" href="/_next/static/css/50425c9106578cba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/50425c9106578cba.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a5d8213a709af092.js" defer=""></script><script src="/_next/static/chunks/175675d1-7de8b3bfdcedb0f1.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c0ab723d8d52e6df.js" defer=""></script><script src="/_next/static/I01GBGHEDt8htGui4sv1q/_buildManifest.js" defer=""></script><script src="/_next/static/I01GBGHEDt8htGui4sv1q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw" style="height:calc(100vh - var(--vh-offset, 0px))"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw"><div class="post_top__JuBkM"><div class="post_b__Bj3sV"><img alt="back" src="/_next/static/media/back.f6d17d78.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div><div class="post_tit__Xu2qi">有关跨域问题的知识点概述<img alt="open" src="/_next/static/media/down.9feac32f.png" width="480" height="480" decoding="async" data-nimg="1" class="post_iconSmall__5Hxz8" loading="lazy" style="color:transparent"/></div><div class="post_b__Bj3sV"><img alt="close" src="/_next/static/media/close.315313d8.png" width="480" height="480" decoding="async" data-nimg="1" class="post_bi__9ghX8" loading="lazy" style="color:transparent"/></div></div><div class="post_mdWarpper__Brjcd"><div class="markdown-body post_md__a6C1y"><h1 id="同源定义">同源定义</h1>
<p>协议、域名、端口号相同。</p>
<h1 id="跨域的几种方式">跨域的几种方式</h1>
<h2 id="jsonp">JSONP</h2>
<h4 id="客户端">客户端</h4>
<ol>
<li>定义获取数据后调用的回调函数</li>
<li>动态生成对服务端JS进行引用的代码<!-- -->
<ul>
<li>设置<code>url</code>为提供<code>jsonp</code>服务的<code>url</code>地址，并在该<code>url</code>中设置相关<code>callback</code>参数</li>
<li>创建<code>script</code>标签，并设置其<code>src</code>属性</li>
<li>把<code>script</code>标签加入<code>head</code>，此时调用开始。</li>
</ul>
</li>
</ol>
<h4 id="服务端">服务端</h4>
<p>将客户端发送的<code>callback</code>参数作为函数名来包裹住<code>JSON</code>数据，返回数据至客户端。</p>
<h3 id="示例">示例</h3>
<h4 id="客户端-1">客户端</h4>
<pre><code class="language-js">// 得到航班信息查询结果后的回调函数
var flightHandler = function(data){
	alert(&#x27;你查询的航班结果是：票价 &#x27; + data.price + &#x27; 元，&#x27; + &#x27;余票 &#x27; + data.tickets + &#x27; 张。&#x27;);
};
// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;
// 创建script标签，设置其属性
var script = document.createElement(&#x27;script&#x27;);
script.setAttribute(&#x27;src&#x27;, url);
// 把script标签加入head，此时调用开始
document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); 
</code></pre>
<h4 id="服务端-1">服务端</h4>
<pre><code class="language-js">flightHandler({
  &quot;code&quot;: &quot;CA1998&quot;,
  &quot;price&quot;: 1780,
  &quot;tickets&quot;: 5
});
</code></pre>
<h2 id="cors">CORS</h2>
<p>主要依托于服务端实现</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p>
<h2 id="postmessageiframe">postMessage+iframe</h2>
<pre><code class="language-html">// a.html
&lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;
//等它加载完触发一个事件
//内嵌在http://localhost:3000/a.html
&lt;script&gt;
function load() {
    let frame = document.getElementById(&#x27;frame&#x27;)
    frame.contentWindow.postMessage(&#x27;我爱你&#x27;, &#x27;http://localhost:4000&#x27;) //发送数据
    window.onmessage = function(e) { //接受返回数据
        console.log(e.data) //我不爱你
    }
}
&lt;/script&gt;

</code></pre>
<pre><code class="language-js">// b.html
  window.onmessage = function(e) {
    console.log(e.data) //我爱你
    e.source.postMessage(&#x27;我不爱你&#x27;, e.origin)
 }

</code></pre>
<h2 id="websocket">WebSocket</h2>
<p>原理：WebSocket 没有同源策略。</p>
<h3 id="使用-socketio">使用 Socket.io</h3>
<p>略，参见 Socket.io 笔记</p>
<h2 id="代理">代理</h2>
<p>原理：服务端没有同源策略</p>
<h3 id="代理服务器">代理服务器</h3>
<ul>
<li>
<p>接受客户端请求 。</p>
</li>
<li>
<p>将请求 转发给服务器。</p>
</li>
<li>
<p>拿到服务器 响应 数据。</p>
</li>
<li>
<p>将 响应 转发给客户端。</p>
</li>
</ul>
<h4 id="实现方式">实现方式</h4>
<p>Node.Js 中间件代理</p>
<p>Nginx 反向代理</p>
<h2 id="iframe">iframe</h2>
<h3 id="通过-windowname">通过 window.name</h3>
<p>window.name 最长可以保存 2MB 的数据。</p>
<h3 id="通过locationhash">通过location.hash</h3>
<h3 id="通过documentdomain">通过document.domain</h3>
<p>只有在同源的情况下，父窗口和子窗口才能通信</p>
<p>实现条件：两个窗口一级域名相同，只是二级域名不同</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p></div></div></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      有关跨域问题的知识点概述\nintro:   \"\"\ndate:       2022-2-23 23:00:00\nauthor:     \"Makinohara\"\ncatalog: true\ntags:\n    - 工程开发\n---\n\n# 同源定义\n\n协议、域名、端口号相同。\n\n# 跨域的几种方式\n\n## JSONP\n\n#### 客户端\n\n1. 定义获取数据后调用的回调函数\n2. 动态生成对服务端JS进行引用的代码\n   - 设置`url`为提供`jsonp`服务的`url`地址，并在该`url`中设置相关`callback`参数\n   - 创建`script`标签，并设置其`src`属性\n   - 把`script`标签加入`head`，此时调用开始。\n\n#### 服务端\n\n将客户端发送的`callback`参数作为函数名来包裹住`JSON`数据，返回数据至客户端。\n\n### 示例\n\n#### 客户端\n\n```js\n// 得到航班信息查询结果后的回调函数\nvar flightHandler = function(data){\n\talert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');\n};\n// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）\nvar url = \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998\u0026callback=flightHandler\";\n// 创建script标签，设置其属性\nvar script = document.createElement('script');\nscript.setAttribute('src', url);\n// 把script标签加入head，此时调用开始\ndocument.getElementsByTagName('head')[0].appendChild(script); \n```\n\n#### 服务端\n\n```js\nflightHandler({\n  \"code\": \"CA1998\",\n  \"price\": 1780,\n  \"tickets\": 5\n});\n```\n\n## CORS\n\n主要依托于服务端实现\n\n服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。\n\n## postMessage+iframe\n\n```html\n// a.html\n\u003ciframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"\u003e\u003c/iframe\u003e\n//等它加载完触发一个事件\n//内嵌在http://localhost:3000/a.html\n\u003cscript\u003e\nfunction load() {\n    let frame = document.getElementById('frame')\n    frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据\n    window.onmessage = function(e) { //接受返回数据\n        console.log(e.data) //我不爱你\n    }\n}\n\u003c/script\u003e\n\n```\n\n```js\n// b.html\n  window.onmessage = function(e) {\n    console.log(e.data) //我爱你\n    e.source.postMessage('我不爱你', e.origin)\n }\n\n```\n\n## WebSocket\n\n原理：WebSocket 没有同源策略。\n\n### 使用 Socket.io\n\n略，参见 Socket.io 笔记\n\n## 代理\n\n原理：服务端没有同源策略\n\n### 代理服务器\n\n- 接受客户端请求 。\n\n- 将请求 转发给服务器。\n\n- 拿到服务器 响应 数据。\n\n- 将 响应 转发给客户端。\n\n#### 实现方式\n\nNode.Js 中间件代理\n\nNginx 反向代理\n\n## iframe\n\n### 通过 window.name\n\nwindow.name 最长可以保存 2MB 的数据。\n\n### 通过location.hash\n\n### 通过document.domain\n\n只有在同源的情况下，父窗口和子窗口才能通信\n\n实现条件：两个窗口一级域名相同，只是二级域名不同\n\n实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2022-2-23-CORS.markdown"},"buildId":"I01GBGHEDt8htGui4sv1q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>