<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4895d80a2f6580a7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4895d80a2f6580a7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/234b6b00259efb8e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/234b6b00259efb8e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-5020794388548d5e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4087c6bf47e90c25.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-c9e0543547ce45e9.js" defer=""></script><script src="/_next/static/chunks/557-10798b428373902a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f16fc4f41fe9d2a0.js" defer=""></script><script src="/_next/static/5VM9oldl4sl0MMj-RVcy7/_buildManifest.js" defer=""></script><script src="/_next/static/5VM9oldl4sl0MMj-RVcy7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="mainLayout_out__ZYqWw"><div class="mainLayout_mainarea__QxaY0"><div class="post_post__ejhnw markdown-body"><h2>WASM + Rust + WebWorker 实现高性能计算器</h2>
<p>假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。</p>
<p>而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。</p>
<p><strong>本文就将实现在 Web Worker 中调用 WASM 进行运算。</strong></p>
<p>首先，我们来编写一段 Rust 代码，用于完成实际的计算。</p>
<pre><code class="language-rust">extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern &quot;C&quot; {}

#[wasm_bindgen]
pub fn wasm_add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。</p>
<p>接下来，我们需要创建一个网页，用于测试我们的函数。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;TestWoker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;module&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>script.js</code>里面，我们要创建一个 Web Worker。</p>
<pre><code class="language-js">if (window.Worker) {
    //加载worker，注意第二个参数要有，否则无法导入 module
    const myWorker = new Worker(&#x27;./worker.js&#x27;, {type: &#x27;module&#x27;});
    myWorker.postMessage([1, 2]);//发送消息
    myWorker.postMessage([3, 4]);//发送消息
    setTimeout(() =&gt; {
        myWorker.postMessage([7, 8])
    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。
    myWorker.onmessage = (m) =&gt; {
        const data = m.data;
        console.log(&#x27;data from wasm: &#x27; + data); //拿到 wasm 计算的结果
    }
}
</code></pre>
<p>然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。</p>
<pre><code class="language-js">import init from &#x27;./pkg/hello_wasm.js&#x27;;
import {wasm_add} from &#x27;./pkg/hello_wasm.js&#x27;;

let isWasmInit = false; //判断是否完成wasm编译

init().then(() =&gt; isWasmInit = true); //初始化Wasm（编译）

onmessage = function (m) {
    const data = m.data;
    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。
        console.log(&#x27;Wasm init before message&#x27;);
        run();
    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。
        console.log(&#x27;Wasm not init before message&#x27;);
        init().then(() =&gt; {
                run();
                isWasmInit = true;
            }
        );
    }

    function run() {
        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数
        postMessage(res);
    }
}
</code></pre>
<p>这样，我们就实现了一个<strong>不阻塞主线程的，高性能</strong>的加法。（好像没有什么卵用</p>
<p>但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？</p></div></div><div class="mainLayout_bottom__As9s_"><div class="mainLayout_tag__Ep3_f"><img alt="launcher" src="/_next/static/media/launcher.d8f01379.png" width="1024" height="1024" decoding="async" data-nimg="1" class="mainLayout_tagImg__qoDJq" loading="lazy" style="color:transparent"/></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"---\nlayout:     post\ntitle:      WASM + Rust + WebWorker 实现计算器（\nintro:   \"\"\ndate:       2022-4-8 23:00:00\nauthor:     \"Mahiru\"\ncatalog: true\ntags:\n    - 工程开发\n---\n\n## WASM + Rust + WebWorker 实现高性能计算器\n\n假设我们现在需要执行一个 CPU 负载很大的运算。为了不阻塞主线程，我们希望用 Web Worker 将其放到一个新的线程中进行运算，这样就可以避免阻塞主线程。\n\n而为了提高这个运算的性能，我们希望用 Rust 编写的 WASM 程序来运算。\n\n**本文就将实现在 Web Worker 中调用 WASM 进行运算。**\n\n首先，我们来编写一段 Rust 代码，用于完成实际的计算。\n\n```rust\nextern crate wasm_bindgen;\n\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nextern \"C\" {}\n\n#[wasm_bindgen]\npub fn wasm_add(a: i32, b: i32) -\u003e i32 {\n    a + b\n}\n```\n\n然后，将其编译为 WASM ，具体的方法参见我的上一篇博文。\n\n接下来，我们需要创建一个网页，用于测试我们的函数。\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003eTestWoker\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cscript type=\"module\" src=\"script.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n在 `script.js`里面，我们要创建一个 Web Worker。\n\n```js\nif (window.Worker) {\n    //加载worker，注意第二个参数要有，否则无法导入 module\n    const myWorker = new Worker('./worker.js', {type: 'module'});\n    myWorker.postMessage([1, 2]);//发送消息\n    myWorker.postMessage([3, 4]);//发送消息\n    setTimeout(() =\u003e {\n        myWorker.postMessage([7, 8])\n    }, 1000); //1秒后发送消息，用于在编译完成后使 worker 收到消息。\n    myWorker.onmessage = (m) =\u003e {\n        const data = m.data;\n        console.log('data from wasm: ' + data); //拿到 wasm 计算的结果\n    }\n}\n```\n\n然后在 Web Worker 里面，导入并编译 WASM 程序，在收到消息的时候执行计算，并将结果返回给主线程。\n\n```js\nimport init from './pkg/hello_wasm.js';\nimport {wasm_add} from './pkg/hello_wasm.js';\n\nlet isWasmInit = false; //判断是否完成wasm编译\n\ninit().then(() =\u003e isWasmInit = true); //初始化Wasm（编译）\n\nonmessage = function (m) {\n    const data = m.data;\n    if (isWasmInit) { //在接收到 message 时，wasm 已经完成编译。\n        console.log('Wasm init before message');\n        run();\n    } else { //在接收到 message 时，wasm 没有完成编译，所以先编译再执行。\n        console.log('Wasm not init before message');\n        init().then(() =\u003e {\n                run();\n                isWasmInit = true;\n            }\n        );\n    }\n\n    function run() {\n        const res = wasm_add(data[0], data[1]); //调用具体的 wasm 函数\n        postMessage(res);\n    }\n}\n```\n\n这样，我们就实现了一个**不阻塞主线程的，高性能**的加法。（好像没有什么卵用\n\n但是想想看，如果这是一个加密或解密算法，或者音视频转码，是不是就很有必要了？\n"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2022-4-8-Wasm-2.markdown"},"buildId":"5VM9oldl4sl0MMj-RVcy7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>